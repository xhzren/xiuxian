/**
 * å‘é‡æ£€ç´¢ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿ
 * ç”¨äºå‡å°‘tokenæ¶ˆè€—ï¼Œå¢å¼ºAIè®°å¿†åŠ›
 */

class ContextVectorManager {
    constructor() {
        this.conversationEmbeddings = []; // å­˜å‚¨æ¯è½®å¯¹è¯çš„å‘é‡å’Œå…ƒæ•°æ®
        this.embeddingMethod = 'keyword'; // 'keyword' | 'api' | 'transformers'
        this.maxRetrieveCount = 5; // æœ€å¤šæ£€ç´¢5æ¡ç›¸å…³å†å²
        this.minSimilarityThreshold = 0.3; // æœ€ä½ç›¸ä¼¼åº¦é˜ˆå€¼
        this.minTurnGap = 10; // ã€è¿œæœŸè®°å¿†ã€‘æœ€å°è½®æ¬¡é—´éš”ï¼šåªæ£€ç´¢è‡³å°‘Nè½®ä¹‹å¤–çš„å¯¹è¯
        this.includeRecentAIRepliesInQuery = 1; // ğŸ†• å‘é‡æ£€ç´¢æ—¶ï¼ŒåŒ…å«æœ€è¿‘Nè½®AIå›å¤ä½œä¸ºæŸ¥è¯¢æ¡ä»¶ï¼ˆ0=ä¸åŒ…å«ï¼Œåªç”¨ç”¨æˆ·è¾“å…¥ï¼‰
        
        // ğŸ†• historyä¸“ç”¨å‘é‡åº“ï¼ˆä»AIå›å¤çš„historyå­—æ®µæå–ï¼‰
        this.historyEmbeddings = []; // å­˜å‚¨historyæ¡ç›®çš„å‘é‡å’Œå…ƒæ•°æ®
        this.recentHistoryCount = 30; // å‘é€æœ€è¿‘å¤šå°‘æ¡historyï¼ˆå¯é…ç½®ï¼‰
        this.matrixHistoryCount = 15; // ä»çŸ©é˜µæ£€ç´¢å¤šå°‘æ¡historyï¼ˆå¯é…ç½®ï¼‰
        
        // ğŸ†• é™æ€çŸ¥è¯†åº“ï¼ˆé¢„å…ˆå‘é‡åŒ–çš„å†…å®¹ï¼‰
        this.staticKnowledgeBase = []; // å­˜å‚¨é¢„åˆ¶çš„çŸ¥è¯†åº“å‘é‡
        this.enableStaticKB = true; // æ˜¯å¦å¯ç”¨é™æ€çŸ¥è¯†åº“æ£€ç´¢
        this.staticKBFiles = []; // çŸ¥è¯†åº“æ–‡ä»¶è·¯å¾„åˆ—è¡¨
        this.autoLoadStaticKB = true; // æ˜¯å¦è‡ªåŠ¨åŠ è½½çŸ¥è¯†åº“
        
        // ğŸ”¥ å™ªéŸ³è¯è¿‡æ»¤è¡¨ï¼ˆå»é™¤å¯¹è¯­ä¹‰è´¡çŒ®ä½çš„è¯ï¼‰- çº¦700ä¸ªè¯
        this.noiseWords = new Set([
            // ===== å½¢å®¹è¯ç±»ï¼ˆçº¦250ä¸ªï¼‰ =====
            // æ„Ÿå®˜æå†™
            'æ¸©çƒ­', 'æ¹¿æ¶¦', 'æŸ”è½¯', 'ç´§è‡´', 'æ¹¿æ»‘', 'æ»šçƒ«', 'å†°å‡‰', 'æ»‘è…»', 'ç²—ç³™', 'å…‰æ»‘',
            'ç«çƒ­', 'æ¸©æš–', 'æ¸…å‡‰', 'ç‚½çƒ­', 'æ¸©æŸ”', 'è½»æŸ”', 'æ¿€çƒˆ', 'çŒ›çƒˆ', 'å‰§çƒˆ', 'å¼ºçƒˆ',
            'é…¥éº»', 'éº»ç—’', 'é…¸ç—›', 'åˆºç—›', 'èƒ€ç—›', 'é—·ç—›', 'å‰§ç—›', 'å¾®ç—›', 'é˜µç—›', 'éšç—›',
            'æ¹¿çƒ­', 'ç‡¥çƒ­', 'æ»šçƒ­', 'å¾®çƒ­', 'å‘çƒ­', 'å‘çƒ«', 'å†°å†·', 'å¯’å†·', 'é˜´å†·', 'å‡‰çˆ½',
            'é¦™ç”œ', 'ç”˜ç”œ', 'è‹¦æ¶©', 'é…¸æ¶©', 'è¾›è¾£', 'éº»è¾£', 'è…¥è‡Š', 'æ¶è‡­', 'æ¸…é¦™', 'æµ“é¦™',
            'å«©æ»‘', 'ç»†æ»‘', 'æ¶¦æ»‘', 'é»ç¨ ', 'ç²˜è…»', 'ç¨ å¯†', 'ç¨€è–„', 'æµ“ç¨ ', 'ç¨€ç–', 'å¯†é›†',
            // å¤§å°/ç¨‹åº¦
            'å·¨å¤§', 'åºå¤§', 'ç¡•å¤§', 'åŒå¤§', 'æå¤§', 'å¾ˆå¤§', 'è¾ƒå¤§', 'è¶…å¤§', 'ç‰¹å¤§', 'æœ€å¤§',
            'å¾®å°', 'ç»†å°', 'æå°', 'å¾ˆå°', 'è¾ƒå°', 'è¶…å°', 'ç‰¹å°', 'æœ€å°', 'æ¸ºå°', 'çŸ®å°',
            'é«˜å¤§', 'é«˜è€¸', 'å·å³¨', 'é›„ä¼Ÿ', 'å®ä¼Ÿ', 'å£®è§‚', 'å®å¤§', 'å¹¿å¤§', 'è¾½é˜”', 'å®½å¹¿',
            'ç‹­å°', 'çª„å°', 'ç‹­çª„', 'ç‹­é•¿', 'ç»†é•¿', 'ä¿®é•¿', 'çº¤é•¿', 'ç»µé•¿', 'æ‚ é•¿', 'æ¼«é•¿',
            'ç²—å¤§', 'ç²—å£®', 'ç²—çŠ·', 'ç²—é‡', 'ç²—ç³™', 'ç²—é²', 'çº¤ç»†', 'çº¤å¼±', 'çº¤å·§', 'ç²¾å·§',
            // é¢œè‰²/å¤–è§‚
            'é›ªç™½', 'æƒ¨ç™½', 'è‹ç™½', 'ç°ç™½', 'æ´ç™½', 'ä¹³ç™½', 'ç²‰ç™½', 'å«©ç™½', 'ç™½çš™', 'ç™½å«©',
            'é²œçº¢', 'çŒ©çº¢', 'è¡€çº¢', 'æ®·çº¢', 'ç»¯çº¢', 'ç²‰çº¢', 'æ¡ƒçº¢', 'å«£çº¢', 'èµ¤çº¢', 'æœ±çº¢',
            'æ¼†é»‘', 'ä¹Œé»‘', 'å¢¨é»‘', 'é»é»‘', 'é»‘æš—', 'å¹½æš—', 'æ˜æš—', 'é˜´æš—', 'ç°æš—', 'æš—æ·¡',
            'ç¢§ç»¿', 'ç¿ ç»¿', 'å«©ç»¿', 'å¢¨ç»¿', 'æ·±ç»¿', 'æµ…ç»¿', 'é’ç»¿', 'è‰ç»¿', 'è‹ç»¿', 'è‘±ç»¿',
            'é‡‘é»„', 'å«©é»„', 'é¹…é»„', 'æé»„', 'æ©™é»„', 'åœŸé»„', 'å§œé»„', 'æ¯é»„', 'ç„¦é»„', 'èœ¡é»„',
            // æƒ…ç»ª/çŠ¶æ€
            'æ„‰å¿«', 'æ¬¢å¿«', 'å¿«ä¹', 'é«˜å…´', 'å…´å¥‹', 'æ¿€åŠ¨', 'ç‹‚å–œ', 'ç‹‚çƒ­', 'çƒ­çƒˆ', 'çƒ­æƒ…',
            'æ‚²ä¼¤', 'å“€ä¼¤', 'å¿§ä¼¤', 'ä¼¤å¿ƒ', 'ç—›è‹¦', 'è‹¦é—·', 'è‹¦æ¼', 'çƒ¦æ¼', 'çƒ¦é—·', 'éƒé—·',
            'æ„¤æ€’', 'æ¼æ€’', 'æ¼ç«', 'ç”Ÿæ°”', 'å‘æ€’', 'æš´æ€’', 'éœ‡æ€’', 'ç‹‚æ€’', 'ç››æ€’', 'å¤§æ€’',
            'ææƒ§', 'å®³æ€•', 'æƒŠæ', 'æƒŠæƒ§', 'æƒŠæ…Œ', 'æ…Œå¼ ', 'æ…Œä¹±', 'ç´§å¼ ', 'ç„¦è™‘', 'ç„¦æ€¥',
            'ç–²æƒ«', 'ç–²åŠ³', 'åŠ³ç´¯', 'å›°å€¦', 'å›°ä¹', 'å€¦æ€ ', 'æ‡’æ•£', 'æ…µæ‡’', 'æ‡’æƒ°', 'æ— åŠ›',
            'æ¸…é†’', 'æ¸…çˆ½', 'æ¸…æ™°', 'æ¸…æ¥š', 'æ˜ç™½', 'æ˜ç¡®', 'æ˜æ˜¾', 'æ˜¾ç„¶', 'æ˜¾è‘—', 'çªå‡º',
            'æ¨¡ç³Š', 'æœ¦èƒ§', 'è¿·ç³Š', 'ç³Šæ¶‚', 'æ··ä¹±', 'å‡Œä¹±', 'æ‚ä¹±', 'é›¶ä¹±', 'çº·ä¹±', 'é”™ä¹±',
            // æ€§è´¨/ç‰¹å¾
            'ç¾ä¸½', 'æ¼‚äº®', 'ç¾å¥½', 'ç¾å¦™', 'ç§€ä¸½', 'å¨‡ç¾', 'è‰³ä¸½', 'ç»šä¸½', 'åä¸½', 'å¯Œä¸½',
            'å¨‡è‰³', 'é²œè‰³', 'è‰³ç¾', 'å¦–è‰³', 'è‰³ä¸½', 'å¨‡åªš', 'å¦©åªš', 'é­…æƒ‘', 'è¯±æƒ‘', 'è¿·äºº',
            'ä¿ä¸½', 'ç§€ç¾', 'æ¸…ç§€', 'å¨Ÿç§€', 'æ¸…ä¸½', 'ç§€é›…', 'ä¼˜é›…', 'å…¸é›…', 'é«˜é›…', 'æ–‡é›…',
            'ä¸‘é™‹', 'éš¾çœ‹', 'ç‹°ç‹', 'å‡¶æ¶', 'å‡¶ç‹ ', 'å‡¶æ®‹', 'æ®‹å¿', 'æ®‹æš´', 'æš´è™', 'å‡¶çŒ›',
            'å’Œå–„', 'å’Œè”¼', 'å’Œæ°”', 'å’Œç¦', 'æ¸©å’Œ', 'æŸ”å’Œ', 'å¹³å’Œ', 'ç¥¥å’Œ', 'å®‰è¯¦', 'æ…ˆç¥¥',
            'çœŸå®', 'çœŸæ­£', 'çœŸåˆ‡', 'ç¡®å®', 'çš„ç¡®', 'ç¡®åˆ‡', 'å‡†ç¡®', 'ç²¾ç¡®', 'æ­£ç¡®', 'æ— è¯¯',
            'è™šå‡', 'è™šå¹»', 'è™šä¼ª', 'å‡è£…', 'ä¼ªè£…', 'åšä½œ', 'çŸ«æƒ…', 'è™šè£', 'è™šæµ®', 'æµ®å¤¸',
            // è¡¥å……å½¢å®¹è¯
            'åˆºçœ¼', 'è€€çœ¼', 'æŸ”å’Œ', 'æ˜äº®', 'é»¯æ·¡', 'æ·±é‚ƒ', 'ç©ºæ´', 'å°–é”', 'åˆºè€³', 'æ‚¦è€³', 'åŠ¨å¬', 'å˜ˆæ‚', 'æ²™å“‘', 'æ¸…è„†', 'æ²‰é—·', 'å¹²ç‡¥', 'æ²¹è…»', 'é»ç³Š', 'æ¾è½¯', 'åšå®', 'åƒµç¡¬', 'é…¥è„†', 'é¦™é†‡', 'é†‡åš', 'æµ“éƒ', 'æ¸…æ–°', 'èŠ¬èŠ³', 'è…¥è‡­', 'è…è‡­',
            'å®‰è¯¦', 'ç¥¥å’Œ', 'å®é™', 'å¹³é™', 'æ·¡å®š', 'ä»å®¹', 'é•‡å®š', 'æ²‰ç€', 'å†·é™', 'æ€¥èº', 'æš´èº', 'çƒ¦èº', 'ä¸å®‰', 'å¿å¿‘', 'è¿·èŒ«', 'å›°æƒ‘', 'ææƒš', 'å¤±ç¥', 'æ²®ä¸§', 'é¢“åºŸ', 'æ¶ˆæ²‰', 'æŒ¯å¥‹', 'æ˜‚æ‰¬', 'å¾—æ„', 'æ»¡è¶³', 'æ¬£æ…°', 'æƒ¬æ„', 'èˆ’ç•…', 'ç©ºè™š', 'å¯‚å¯', 'å­¤ç‹¬',
            'ä¼˜ç§€', 'ä¼˜è‰¯', 'è‰¯å¥½', 'å‡ºè‰²', 'å“è¶Š', 'æ°å‡º', 'ç³Ÿç³•', 'æ¶åŠ£', 'ä½åŠ£', 'æ™®é€š', 'å¹³å‡¡', 'å¹³åº¸', 'éå‡¡', 'è¶…å‡¡', 'ç¥åœ£', 'åœ£æ´', 'çº¯æ´', 'çº¯ç²¹', 'æ±¡æµŠ', 'è‚®è„', 'çº¯å‡€', 'é«˜è´µ', 'å‘å¾®', 'æ¸ºå°', 'ä¼Ÿå¤§', 'å´‡é«˜', 'å…³é”®', 'æ ¸å¿ƒ', 'é‡è¦', 'æ¬¡è¦',
            // å†æ¬¡è¡¥å……å½¢å®¹è¯
            'ç‹¬ç‰¹', 'å…¸å‹', 'æ ‡å‡†', 'ä¼ ç»Ÿ', 'ç°ä»£', 'å¤å…¸', 'æµè¡Œ', 'ç½•è§', 'å¸¸è§', 'æ™®é', 'å…·ä½“', 'æŠ½è±¡', 'å®Œæ•´', 'æ®‹ç¼º', 'é›¶æ•£', 'ç³»ç»Ÿ', 'ç¨³å®š', 'åŠ¨è¡', 'å¯é ', 'å¯ä¿¡', 'å¯ç–‘',
            'æ•´é½', 'å·¥æ•´', 'æ½¦è‰', 'æ­ªæ–œ', 'ç¬”ç›´', 'å¼¯æ›²', 'å¹³å¦', 'å´å²–', 'ç²¾è‡´', 'æœ´ç´ ', 'å•è°ƒ', 'ä¸°å¯Œ', 'ç©ºæ—·', 'æ‹¥æŒ¤', 'æ•´æ´', 'å‡Œä¹±',
            'ç»å¯¹', 'ç›¸å¯¹', 'å½»åº•', 'å®Œå…¨', 'éƒ¨åˆ†', 'ä¸´æ—¶', 'æ°¸ä¹…', 'é•¿æœŸ', 'çŸ­æœŸ', 'ç´§æ€¥', 'ç¼“æ…¢', 'è¿…é€Ÿ', 'å‰§çƒˆ', 'æ¸©å’Œ', 'ä¸¥é‡', 'è½»å¾®', 'æ ¹æœ¬', 'è¡¨é¢',
            // 20240521 å†æ¬¡è¡¥å……
            'å¹³æ»‘', 'å‡¹å‡¸', 'æµç•…', 'ç”Ÿæ¶©', 'æ¾æ•£', 'ç´§å‡‘', 'è“¬æ¾', 'å¹²ç˜ª', 'é™æ­¢', 'åŠ¨æ€', 'é™æ€', 'æŒç»­', 'çŸ­æš‚', 'å…¬å¼€', 'ç§˜å¯†', 'ç§äºº', 'å…¬å…±', 'å®˜æ–¹', 'æ°‘é—´', 'æ­£å¼', 'éæ­£å¼', 'åˆæ³•', 'éæ³•', 'åˆç†', 'ä¸åˆç†',
            'å°´å°¬', 'ç¾æ¶©', 'å®³ç¾', 'è‡ªè±ª', 'å¤±è½', 'ç»æœ›', 'ä¹è§‚', 'æ‚²è§‚', 'æ”¾æ¾', 'å‹æŠ‘', 'çº ç»“', 'å¦ç„¶', 'ä»å®¹', 'æ·¡ç„¶', 'æ¼ ç„¶',
            'å¥½', 'å', 'å¯¹', 'é”™', 'çœŸ', 'å‡', 'å–„', 'æ¶', 'ç¾', 'ä¸‘', 'é«˜çº§', 'ä½çº§', 'åˆçº§', 'ä¸­çº§', 'é¡¶çº§',
            // è¡¥å……åŠ¨è¯å’Œå‰¯è¯
            'å°è¯•', 'è¯•å›¾', 'è®¾æ³•', 'æƒ³è¦', 'è¦æ±‚', 'å‘½ä»¤', 'å‚¬ä¿ƒ', 'æé†’', 'ç¤ºæ„', 'æœ›å‘', 'çœ‹å‘', 'ç›¯ç€', 'æ³¨è§†', 'ç¥è§', 'å¬è§', 'é—»åˆ°', 'å—…åˆ°', 'è§¦ç¢°', 'ç¢°åˆ°', 'æ‘¸åˆ°', 'æ‹¿èµ·', 'æ”¾ä¸‹', 'ä¸¾èµ·', 'æŒ¥åŠ¨', 'æŒ‡å‘', 'é¢å¯¹', 'èƒŒå¯¹', 'è·Ÿéš', 'è¿½èµ¶', 'é€ƒç¦»',
            'å¾„ç›´', 'å¾„è‡ª', 'è‡ªè¡Œ', 'äº²è‡ª', 'å•ç‹¬', 'ä¸€åŒ', 'ä¸€èµ·', 'åå¤', 'å†ä¸‰', 'å±¡æ¬¡', 'æ‚„ç„¶', 'èµ«ç„¶', 'ä¾ç„¶', 'ä»ç„¶', 'ç…§æ—§',
            // é€»è¾‘ä¸æŠ½è±¡æ¦‚å¿µ
            'ä¾‹å¦‚', 'æ¯”å¦‚', 'æ‰€è°“', 'æ€»ä¹‹', 'æ¯•ç«Ÿ', 'åæ­£', 'éš¾é“', 'è«é', 'é™¤é', 'å¦åˆ™', 'ä¸€æ—¦', 'æ—¢ç„¶', 'ç”šè‡³', 'å°¤å…¶', 'åè€Œ', 'è€Œæ˜¯', 'å®æ„¿', 'å®å¯', 'ä¸å…¶', 'ä¸å¦‚',
            'åŸå› ', 'ç»“æœ', 'ç›®çš„', 'æ–¹å¼', 'è¿‡ç¨‹', 'æ¡ä»¶', 'åŸºç¡€', 'æ ¸å¿ƒ', 'é‡ç‚¹', 'å…³é”®', 'æœ¬è´¨', 'ç°è±¡', 'è§„å¾‹', 'åŸåˆ™', 'èŒƒå›´', 'ç¨‹åº¦', 'æ°´å¹³', 'æ ‡å‡†', 'åŠŸèƒ½', 'ä½œç”¨',
            
            // ===== å‰¯è¯ç±»ï¼ˆçº¦200ä¸ªï¼‰ =====
            // ç¨‹åº¦å‰¯è¯
            'éå¸¸', 'ååˆ†', 'æå…¶', 'æä¸º', 'æåº¦', 'æ ¼å¤–', 'ç‰¹åˆ«', 'å°¤å…¶', 'å¼‚å¸¸', 'ç›¸å½“',
            'é¢‡ä¸º', 'é¢‡æœ‰', 'ç”šä¸º', 'ç”šæ˜¯', 'è¿‡äº', 'å¤ªè¿‡', 'è¿‡åˆ†', 'è¿‡åº¦', 'ç¨å¾®', 'ç•¥å¾®',
            'ç¨ç¨', 'ç•¥ç•¥', 'æœ‰äº›', 'æœ‰ç‚¹', 'ä¸€äº›', 'å‡ åˆ†', 'äº›è®¸', 'ä¸€ç‚¹', 'ä¸€ä¸', 'ä¸æ¯«',
            'æ›´åŠ ', 'è¶Šå‘', 'æ„ˆå‘', 'æ„ˆåŠ ', 'æ›´ä¸º', 'æ›´æ˜¯', 'å°¤ä¸º', 'å°¤å…¶', 'å°¤ç”š', 'è‡³ä¸º',
            'æœ€ä¸º', 'æœ€æ˜¯', 'ææ˜¯', 'å®åœ¨', 'ç€å®', 'ç¡®å®', 'çš„ç¡®', 'å§”å®', 'å®å±', 'å½“çœŸ',
            // æ—¶é—´å‰¯è¯
            'çªç„¶', 'å¿½ç„¶', 'çŒ›ç„¶', 'è“¦ç„¶', 'éœç„¶', 'é™¡ç„¶', 'éª¤ç„¶', 'ä¹ç„¶', 'æ‚šç„¶', 'æ€¦ç„¶',
            'ç«‹åˆ»', 'ç«‹å³', 'ç«‹æ—¶', 'å³åˆ»', 'å³æ—¶', 'é¡¿æ—¶', 'åˆ¹æ—¶', 'éœæ—¶', 'æ—‹å³', 'éšå³',
            'é©¬ä¸Š', 'å½“å³', 'å½“ä¸‹', 'å½“æ—¶', 'æ­¤æ—¶', 'æ­¤åˆ»', 'æ­¤é™…', 'è¿™æ—¶', 'é‚£æ—¶', 'å½¼æ—¶',
            'ç¬é—´', 'åˆ¹é‚£', 'éœé‚£', 'é¡»è‡¾', 'ç‰‡åˆ»', 'é¡·åˆ»', 'è½¬çœ¼', 'çœ¨çœ¼', 'å¼¹æŒ‡', 'ä¸€ç¬',
            'æ¸æ¸', 'é€æ¸', 'æ…¢æ…¢', 'ç¼“ç¼“', 'å¾å¾', 'æ‚ æ‚ ', 'ç¼“ç¼“', 'å¾å¾', 'æ¬¾æ¬¾', 'å§—å§—',
            'ä»æ¥', 'å‘æ¥', 'å†æ¥', 'ç´ æ¥', 'ä¸€å‘', 'å§‹ç»ˆ', 'ç»ˆäº', 'ç»ˆç©¶', 'ç»ˆå½’', 'æ¯•ç«Ÿ',
            'å·²ç»', 'æ›¾ç»', 'æ—©å·²', 'ä¸šå·²', 'æ—¢å·²', 'åˆšåˆš', 'åˆšæ‰', 'æ–¹æ‰', 'é€‚æ‰', 'æ‰åˆš',
            'å³å°†', 'å°†è¦', 'å¿«è¦', 'å°±è¦', 'è¡Œå°†', 'æ­£è¦', 'æ­£åœ¨', 'æ­£å€¼', 'æ°å€¼', 'æ°é€¢',
            // æ–¹å¼å‰¯è¯
            'æ‚„æ‚„', 'å·å·', 'æš—æš—', 'é»˜é»˜', 'é™é™', 'è½»è½»', 'ç¼“ç¼“', 'æ…¢æ…¢', 'å¾å¾', 'æ¬¾æ¬¾',
            'ç‹ ç‹ ', 'é‡é‡', 'æ­»æ­»', 'ç´§ç´§', 'ç‰¢ç‰¢', 'ç¨³ç¨³', 'å®å®', 'åˆ‡åˆ‡', 'çœŸçœŸ', 'ç¡®ç¡®',
            'çŒ›åœ°', 'ç‹ ç‹ ', 'ç”¨åŠ›', 'ä½¿åŠ²', 'å¥‹åŠ›', 'æåŠ›', 'ç«­åŠ›', 'å…¨åŠ›', 'å°½åŠ›', 'æ‹¼å‘½',
            'å‹‰å¼º', 'å¼ºè¡Œ', 'ç¡¬æ˜¯', 'ç”Ÿç”Ÿ', 'ç¡¬ç”Ÿ', 'æ´»ç”Ÿ', 'æ„£æ˜¯', 'åå', 'åç”Ÿ', 'åè¦',
            'ä»”ç»†', 'ç»†ç»†', 'è®¤çœŸ', 'ä¸“å¿ƒ', 'ç”¨å¿ƒ', 'ç•™å¿ƒ', 'å°å¿ƒ', 'è°¨æ…', 'æ…é‡', 'éƒ‘é‡',
            'éšæ„', 'éšä¾¿', 'ä»»æ„', 'éšæ‰‹', 'éšå£', 'ä¿¡æ‰‹', 'ä¿¡å£', 'è„±å£', 'é¡ºå£', 'é¡ºæ‰‹',
            
            // ===== è¿è¯/ä»‹è¯/åŠ©è¯ï¼ˆçº¦100ä¸ªï¼‰ =====
            'ç„¶è€Œ', 'ä½†æ˜¯', 'å¯æ˜¯', 'ä¸è¿‡', 'åªæ˜¯', 'è€Œæ˜¯', 'å´æ˜¯', 'å€’æ˜¯', 'åè€Œ', 'åå€’',
            'è€Œä¸”', 'å¹¶ä¸”', 'å†µä¸”', 'ä½•å†µ', 'ä½•æ­¢', 'å²‚æ­¢', 'ä¸ä½†', 'ä¸ä»…', 'ä¸åª', 'ä¸å…‰',
            'æˆ–è€…', 'æˆ–æ˜¯', 'æŠ‘æˆ–', 'è¦ä¹ˆ', 'è¿˜æ˜¯', 'äº¦æˆ–', 'ä»¥åŠ', 'åŠå…¶', 'å¹¶',  'ä¸',
            'å› ä¸º', 'ç”±äº', 'å› ', 'ç¼˜äº', 'ä¸ºäº†', 'ä»¥ä¾¿', 'ä¸ºçš„', 'å¥½è®©', 'ä½¿å¾—', 'ä»¤å¾—',
            'æ‰€ä»¥', 'å› æ­¤', 'å› è€Œ', 'æ•…è€Œ', 'ä»è€Œ', 'ä»¥è‡³', 'è‡´ä½¿', 'å¯¼è‡´', 'å¼•èµ·', 'é€ æˆ',
            'å¦‚æœ', 'å‡å¦‚', 'å€˜è‹¥', 'è‹¥æ˜¯', 'è¦æ˜¯', 'å‡ä½¿', 'å‡è‹¥', 'è®¾è‹¥', 'è®¾ä½¿', 'ä¸‡ä¸€',
            'è™½ç„¶', 'å°½ç®¡', 'å³ä½¿', 'çºµä½¿', 'çºµç„¶', 'å°±ç®—', 'å“ªæ€•', 'ä¾¿æ˜¯', 'å³ä¾¿', 'ä»»å‡­',
            'æ— è®º', 'ä¸è®º', 'ä¸ç®¡', 'æ— è®º', 'ä»»å‡­', 'å‡­', 'éš', 'è¶', 'ä¹˜', 'å½“',
            'å¯¹äº', 'å…³äº', 'è‡³äº', 'è®ºåŠ', 'è¯´åˆ°', 'æåˆ°', 'è°ˆåˆ°', 'è®²åˆ°', 'åŠè‡³', 'ç›´åˆ°',
            'é€šè¿‡', 'ç»è¿‡', 'é€è¿‡', 'ç©¿è¿‡', 'å‡­å€Ÿ', 'ä¾é ', 'ä»°ä»—', 'ä¾èµ–', 'å€ŸåŠ©', 'åˆ©ç”¨',
            'åœ¨äº', 'ä½äº', 'å¤„äº', 'å±…äº', 'ç«‹äº', 'å­˜åœ¨', 'å±äº', 'å½’äº', 'éš¶å±', 'ä»å±',
            
            // ===== å¸¸è§åŠ¨è¯ï¼ˆæ³›åŒ–ï¼Œçº¦80ä¸ªï¼‰ =====
            'æ„Ÿè§‰', 'è§‰å¾—', 'æ„Ÿåˆ°', 'æ„Ÿå—', 'ä½“ä¼š', 'ä½“éªŒ', 'é¢†ä¼š', 'é¢†æ‚Ÿ', 'æ„è¯†', 'å¯Ÿè§‰',
            'å‘ç°', 'å‘è§‰', 'å¯Ÿè§‰', 'æ³¨æ„', 'ç•™æ„', 'åœ¨æ„', 'ä»‹æ„', 'ç†ä¼š', 'ç†ç¬', 'æ­ç†',
            'çœ‹åˆ°', 'çœ‹è§', 'ç§è§', 'ç…è§', 'æœ›è§', 'è§åˆ°', 'ç›®ç¹', 'ç›®å‡»', 'çœ‹å‡º', 'çœ‹æ¸…',
            'å¬åˆ°', 'å¬è§', 'å¬é—»', 'é—»å¬', 'å¾—çŸ¥', 'å¾—æ‚‰', 'è·æ‚‰', 'çŸ¥æ‚‰', 'çŸ¥æ™“', 'æ™“å¾—',
            'çŸ¥é“', 'æ˜ç™½', 'äº†è§£', 'ç†è§£', 'æ‡‚å¾—', 'æ™“å¾—', 'æ¸…æ¥š', 'æ˜äº†', 'æ˜ç¡®', 'ç¡®å®š',
            'ä¼¼ä¹', 'å¥½åƒ', 'å¥½ä¼¼', 'ä»¿ä½›', 'å®›å¦‚', 'çŠ¹å¦‚', 'å¦‚åŒ', 'åƒæ˜¯', 'æè‹¥', 'å®›è‹¥',
            'å¼€å§‹', 'èµ·å§‹', 'å§‹äº', 'å¯åŠ¨', 'å‘åŠ¨', 'å¼€å¯', 'å¯ç¨‹', 'åŠ¨èº«', 'å‡ºå‘', 'èµ·èº«',
            'ç»§ç»­', 'æŒç»­', 'å»¶ç»­', 'æ¥ç»­', 'è¿ç»­', 'é™†ç»­', 'ç›¸ç»§', 'æ¥è¿', 'ä¸æ–­', 'ä¸€ç›´',
            
            // ===== é‡è¯/æ•°è¯ï¼ˆçº¦50ä¸ªï¼‰ =====
            'ä¸€äº›', 'ä¸€ç‚¹', 'ä¸€ä¸‹', 'ä¸€ç•ª', 'ä¸€é˜µ', 'ä¸€ç‰‡', 'ä¸€è‚¡', 'ä¸€ä¸', 'ä¸€ç¼•', 'ä¸€æŠ¹',
            'ä¸€é“', 'ä¸€å£°', 'ä¸€å¥', 'ä¸€è¨€', 'ä¸€å›', 'ä¸€é', 'ä¸€æ¬¡', 'ä¸€åœº', 'ä¸€é¡¿', 'ä¸€é€š',
            'å‡ ä¸ª', 'å‡ åˆ†', 'å‡ è®¸', 'å‡ ç•ª', 'å¥½å‡ ', 'è‹¥å¹²', 'æ•°ä¸ª', 'æ•°æ¬¡', 'å¤šæ¬¡', 'å±¡æ¬¡',
            'è®¸å¤š', 'å¾ˆå¤š', 'å¥½å¤š', 'ä¸å°‘', 'å¤§é‡', 'å°‘é‡', 'æµ·é‡', 'å·¨é‡', 'å¾®é‡', 'æå°‘',
            'ä¼—å¤š', 'è¯¸å¤š', 'ç¹å¤š', 'é¢‡å¤š', 'é¢‡ä¸º', 'é¢‡æœ‰', 'äº›è®¸', 'ä¸æ¯«', 'ç‚¹æ»´', 'åˆ†æ¯«',
            
            // ===== ä»£è¯ï¼ˆçº¦30ä¸ªï¼‰ =====
            'è¿™ä¸ª', 'é‚£ä¸ª', 'è¿™äº›', 'é‚£äº›', 'è¿™æ ·', 'é‚£æ ·', 'å¦‚æ­¤', 'è¿™èˆ¬', 'é‚£èˆ¬', 'æ­¤ç­‰',
            'è¿™é‡Œ', 'é‚£é‡Œ', 'æ­¤å¤„', 'å½¼å¤„', 'è¿™è¾¹', 'é‚£è¾¹', 'æ­¤é—´', 'å…¶é—´', 'å½“ä¸­', 'ä¹‹ä¸­',
            'è‡ªå·±', 'æœ¬äºº', 'è‡ªèº«', 'è‡ªæˆ‘', 'å½¼æ­¤', 'ç›¸äº’', 'äº’ç›¸', 'å¤§å®¶', 'ä¼—äºº', 'è¯¸ä½',
            
            // ===== è¯­æ°”è¯/å¹è¯ï¼ˆçº¦30ä¸ªï¼‰ =====
            'çš„è¯', 'æ¥ç€', 'ç½¢äº†', 'è€Œå·²', 'ä¹‹ç±»', 'ä»€ä¹ˆçš„', 'å•¥çš„', 'å’‹çš„', 'æ€ä¹ˆçš„',
            'å‘¢', 'å—', 'å§', 'å•Š', 'å“', 'å”‰', 'å“¦', 'å“Ÿ', 'å˜¿', 'å—¯', 'å“¼', 'å˜›', 'å‘', 'å“ª',
            'å‘€', 'å•¦', 'å–½', 'å’§', 'å“©', 'å˜', 'å–”', 'å“‡', 'å‘—',
            
            // ===== å…¶ä»–è™šè¯ï¼ˆçº¦20ä¸ªï¼‰ =====
            'ä¹‹', 'å…¶', 'ä¹ƒ', 'äº', 'ä»¥', 'ä¸º', 'åˆ™', 'å³', 'è‹¥', 'ä¸”',
            'ä¹Ÿ', 'äº¦', 'çŸ£', 'ç„‰', 'è€³', 'å“‰', 'ä¹', 'è€…', 'æ‰€', 'æ–¯',
            // è¡¥å¢äºŒå­—è¯
            'å®‰é™', 'å¯‚é™', 'å–§é—¹', 'å¹²å‡€', 'æ•´æ´', 'å®‰å…¨', 'å±é™©', 'å‡ºç°', 'æ¶ˆå¤±', 'å‘ç”Ÿ',
            'æƒ…å†µ', 'å¿ƒä¸­', 'çœ¼ä¸­', 'é¢å‰', 'èº«å',
            'èµ°å»', 'èµ°æ¥', 'è·‘å»', 'çœ‹ç€', 'å¬ç€', 'æƒ³ç€', 'æ‹¿ç€', 'åä¸‹', 'ç«™èµ·', 'èººä¸‹', 'é†’æ¥', 'å›åˆ°', 'æ¥åˆ°', 'å»åˆ°', 'è§åˆ°', 'è¯´åˆ°', 'åšåˆ°', 'æƒ³åˆ°', 'å¾—åˆ°', 'å¤±å»', 'æˆä¸º', 'å˜ä¸º', 'æ‹¥æœ‰', 'åŒ…å«', 'æ™®é€š', 'ä¸€èˆ¬', 'æ­£å¸¸', 'ç‰¹æ®Š', 'å¥‡æ€ª', 'ç®€å•', 'å¤æ‚', 'å®¹æ˜“', 'å›°éš¾', 'é‡è¦', 'æ¬¡è¦', 'ä¸»è¦', 'åŸºæœ¬', 'è¡¨é¢', 'å†…éƒ¨', 'å¤–éƒ¨',
            // è¡¥å¢ä¸‰å­—è¯
            'çœ‹èµ·æ¥', 'å¬èµ·æ¥', 'èµ°ä¸Šå‰', 'åœä¸‹æ¥', 'ä¸çŸ¥é“', 'ä¸æ˜ç™½', 'ä¸€æ—¶é—´', 'åˆ¹é‚£é—´', 'ç´§æ¥ç€',
            'èµ°è¿‡æ¥', 'èµ°è¿‡å»', 'è·‘è¿‡æ¥', 'è·‘è¿‡å»', 'é£è¿‡æ¥', 'çœ‹è¿‡å»', 'å¬ä¸Šå»', 'æ‘¸ä¸Šå»', 'æƒ³èµ·æ¥', 'æƒ³ä¸åˆ°', 'çœ‹ä¸åˆ°', 'å¬ä¸åˆ°', 'æ‘¸ä¸ç€', 'å¿ä¸ä½', 'å—ä¸äº†', 'é¡¾ä¸ä¸Š', 'æ¥ä¸åŠ', 'èˆä¸å¾—', 'æ”¾ä¸ä¸‹', 'æ‹¿èµ·æ¥', 'æ”¾ä¸‹å»', 'åä¸‹æ¥', 'ç«™èµ·æ¥', 'èººä¸‹å»', 'é†’è¿‡æ¥', 'å›è¿‡å¤´', 'è½¬è¿‡èº«', 'ä½ä¸‹å¤´', 'æŠ¬èµ·å¤´', 'ä¼¸å‡ºæ‰‹', 'ä¸€ç¬é—´', 'ä¸€åˆ¹é‚£', 'ä¸€è½¬çœ¼', 'ä¸€çœ¨çœ¼', 'æ¥ä¸‹æ¥', 'ä¸æ­¤åŒæ—¶', 'æ€»è€Œè¨€ä¹‹', 'æ¢å¥è¯è¯´', 'æ¯”å¦‚è¯´', 'å®é™…ä¸Š', 'äº‹å®ä¸Š', 'æ€»çš„æ¥è¯´', 'å…·ä½“æ¥è¯´', 'ç›¸å¯¹æ¥è¯´', 'æ²¡ä»€ä¹ˆ', 'æ²¡å…³ç³»', 'ä¸è¦ç´§', 'æ€ä¹ˆæ ·', 'æ€ä¹ˆåŠ', 'ä¸ºä»€ä¹ˆ', 'æ˜¯ä¸æ˜¯', 'å¯¹ä¸å¯¹', 'å¥½ä¸å¥½',
            // è¡¥å¢å››å­—æˆè¯­
            'ä¸€ä¸¾ä¸€åŠ¨', 'ä¸€ä¸¾ä¸¤å¾—', 'ä¸€ä¸ä¸è‹Ÿ', 'ä¸€è¨€ä¸ºå®š', 'ä¸€å¸†é£é¡º', 'ä¸€é¸£æƒŠäºº', 'ä¸€è§é’Ÿæƒ…', 'ä¸€å¿ƒä¸€æ„', 'ä¸€æ¸…äºŒæ¥š', 'ä¸€æ¨¡ä¸€æ ·',
            'ä¸ƒä¸Šå…«ä¸‹', 'ä¸ƒå˜´å…«èˆŒ', 'ä¸‡æ— ä¸€å¤±', 'ä¸‡ä¼—ä¸€å¿ƒ', 'ä¸‰å¿ƒäºŒæ„', 'ä¸‹ä¸ä¸ºä¾‹', 'ä¸ä¸‰ä¸å››', 'ä¸çŸ¥ä¸è§‰', 'ä¸çº¦è€ŒåŒ', 'ä¸æ‹©æ‰‹æ®µ',
            'ä¸ç”±è‡ªä¸»', 'ä¸œå¼ è¥¿æœ›', 'ä¹±ä¸ƒå…«ç³Ÿ', 'äº”èŠ±å…«é—¨', 'äº•äº•æœ‰æ¡', 'ä»Šéæ˜”æ¯”', 'ä»å®¹ä¸è¿«', 'å¾—æ„æ´‹æ´‹', 'æ°åˆ°å¥½å¤„', 'å…¨åŠ›ä»¥èµ´',
            'å…´é«˜é‡‡çƒˆ', 'å…¨ç¥è´¯æ³¨', 'å‡ºäººæ„æ–™', 'åƒæ–¹ç™¾è®¡', 'åƒè¨€ä¸‡è¯­', 'åƒè¾›ä¸‡è‹¦', 'åƒè½½éš¾é€¢', 'åŠé€”è€ŒåºŸ', 'å—è¾•åŒ—è¾™', 'åå‰¯å…¶å®',
            'åé¡¾ä¹‹å¿§', 'å–œå‡ºæœ›å¤–', 'å–‹å–‹ä¸ä¼‘', 'å››é¢å…«æ–¹', 'å› å°å¤±å¤§', 'åšå®šä¸ç§»', 'å¤§åƒä¸€æƒŠ', 'å¤§åŒå°å¼‚', 'å¤§æƒŠå°æ€ª', 'å¤§æå°ç”¨',
            'å¤§æ˜¾èº«æ‰‹', 'å¤©é•¿åœ°ä¹…', 'å¤©ç¿»åœ°è¦†', 'å¤©ç½—åœ°ç½‘', 'å¤©é«˜åœ°åš', 'å¤±é­‚è½é­„', 'å¤´å¤´æ˜¯é“', 'å¥‡æ€å¦™æƒ³', 'å¦‚æ„¿ä»¥å¿', 'å¦™ä¸å¯è¨€',
            'å®Œç¾æ— ç‘•', 'å¯¸æ­¥ä¸ç¦»', 'å°å¿ƒç¿¼ç¿¼', 'å±‚å‡ºä¸ç©·', 'å±±æ¸…æ°´ç§€', 'å·æµä¸æ¯', 'åºŸå¯å¿˜é£Ÿ', 'å¼•äººæ³¨ç›®', 'å¿ƒå¹³æ°”å’Œ', 'å¿ƒç”˜æƒ…æ„¿',
            'æƒ…ä¸è‡ªç¦', 'æç„¶å¤§æ‚Ÿ', 'æ¯æ¯ç›¸å…³', 'æƒ³æ–¹è®¾æ³•', 'æ„çœ‰è‹¦è„¸', 'æ‰‹å¿™è„šä¹±', 'æ— ä¸ä¼¦æ¯”', 'æ— å¾®ä¸è‡³', 'æ— å¿§æ— è™‘', 'æ— æ‰€äº‹äº‹',
            'æ— èƒ½ä¸ºåŠ›', 'æ— ç²¾æ‰“é‡‡', 'æ—¥æ–°æœˆå¼‚', 'æ—¶æ—¶åˆ»åˆ»', 'æ˜¾è€Œæ˜“è§', 'æ¬£æ¬£å‘è£', 'æ»”æ»”ä¸ç»', 'ç†æ‰€å½“ç„¶', 'ç”»è›‡æ·»è¶³', 'ç›®ä¸è½¬ç›',
            'ç­‹ç–²åŠ›å°½', 'è‡ªè¨€è‡ªè¯­', 'è‡ªç”±è‡ªåœ¨', 'è‡ªå§‹è‡³ç»ˆ', 'è«åå…¶å¦™', 'èæ°´ç›¸é€¢', 'è£…æ¨¡ä½œæ ·', 'èµå¿ƒæ‚¦ç›®', 'è½»è€Œæ˜“ä¸¾', 'è¿«ä¸åŠå¾…',
            // 20240521 è¡¥å……
            'èƒ½å¤Ÿ', 'å¯ä»¥', 'éœ€è¦', 'æ„¿æ„', 'å¸Œæœ›', 'æ‰“ç®—', 'å‡†å¤‡', 'å†³å®š', 'ç»§ç»­', 'åœæ­¢', 'ç¦»å¼€', 'å‡ºæ¥', 'ä¸Šå»', 'ä¸‹æ¥', 'è¿‡å»', 'è¿‡æ¥', 'ä¸€åˆ‡', 'æ‰€æœ‰', 'éƒ¨åˆ†', 'å…¨éƒ¨', 'å¿½ç„¶', 'æ¸æ¸', 'ç»ˆäº', 'æœ€å', 'å½“åˆ', 'åæ¥', 'ç°åœ¨', 'æœªæ¥', 'ä¸€ç›´', 'æ€»æ˜¯', 'ç»å¸¸', 'å¶å°”', 'æœ‰æ—¶', 'å†æ¬¡', 'é‡æ–°', 'å…³äº', 'é™¤äº†', 'éšç€', 'æ ¹æ®', 'æŒ‰ç…§', 'ç„¶è€Œ', 'æ‰€ä»¥', 'ä»¿ä½›', 'ä¼¼ä¹', 'ä¸å¦‚', 'ä½•å¿…',
            'è¯´ä¸å®š', 'ä¹Ÿè®¸æ˜¯', 'å¯èƒ½æ˜¯', 'å·®ä¸å¤š', 'å¦ä¸€è¾¹', 'å¦ä¸€å¤´', 'å¦ä¸€é¢', 'æ­£å‰æ–¹', 'æ­£åæ–¹', 'æ­£ä¸Šæ–¹', 'æ­£ä¸‹æ–¹', 'ä¸‹æ„è¯†', 'æ½œæ„è¯†', 'ä¸ç”±å¾—', 'æ— è®ºå¦‚', 'ä¸ç®¡æ€', 'å¤šå¤šå°‘', 'æˆ–å¤šæˆ–', 'çœ‹æ ·å­', 'çœ‹èµ·æ¥', 'å¬èµ·æ¥', 'é—»èµ·æ¥', 'æ‘¸èµ·æ¥', 'å°èµ·æ¥', 'åˆ°å¤´æ¥', 'è¯´åˆ°åº•', 'æ€»è€Œè¨€', 'æ¢å¥è¯', 'è¯´å®è¯', 'è€å®è¯´', 'å¦ç™½è¯´', 'äº‹å®ä¸Š', 'å®é™…ä¸Š', 'æ— è®ºä½•', 'æ— è®ºå¦‚', 'æ€»çš„æ¥', 'å…·ä½“çš„', 'ç›¸å¯¹çš„', 'åŸºæœ¬ä¸Š', 'å¤§ä½“ä¸Š',
            'ä¸çŸ¥æ‰€æª', 'ä¸çŸ¥å¥½æ­¹', 'ä¸çŸ¥æ‰€ä»¥', 'æ— å¯å¥ˆä½•', 'æ— å¯éè®®', 'é¡ºå…¶è‡ªç„¶', 'å¬å¤©ç”±å‘½', 'å¤§æƒŠå¤±è‰²', 'é¢ä¸æ”¹è‰²', 'ä¸åŠ¨å£°è‰²', 'è‡ªä»¥ä¸ºæ˜¯', 'è‡ªä½œèªæ˜', 'å‰æ‰€æœªæœ‰', 'å²æ— å‰ä¾‹', 'ä¸¾æ‰‹ä¹‹åŠ³', 'æºæºä¸æ–­', 'ç»œç»ä¸ç»', 'å„å¼å„æ ·', 'å„ç§å„æ ·', 'ç›¸æå¹¶è®º', 'åŒæ—¥è€Œè¯­', 'ä¸çŸ¥å‡¡å‡ ', 'æ•°ä¸èƒœæ•°', 'æ¥äºŒè¿ä¸‰', 'æ¥æ¥å›å›', 'ååå¤å¤', 'å½»å¤´å½»å°¾', 'å½»å½»åº•åº•', 'åŸåŸæœ¬æœ¬', 'å®äº‹æ±‚æ˜¯', 'æ€»è€Œè¨€ä¹‹', 'æ€»çš„æ¥è¯´', 'æ¯«æ— ç–‘é—®', 'æ¯«æ— ä¿ç•™', 'æ¯«æ— æ€¨è¨€', 'æ¯«æ— å¾å…†', 'ä¸æ­¤åŒæ—¶', 'é™¤æ­¤ä¹‹å¤–', 'æ¢å¥è¯è¯´', 'ä¸€å¦‚æ—¢å¾€', 'ä¸€æœä¸€å¤•', 'é•¿æ­¤ä»¥å¾€', 'é•¿è¯çŸ­è¯´', 'ç®€è€Œè¨€ä¹‹', 'è¨€å½’æ­£è½¬', 'æ— è®ºå¦‚ä½•', 'ä¸ç®¡æ€æ ·', 'ä¸ç®¡ä¸é¡¾',
            // æˆ˜æ–—åœºæ™¯
            'æ”»å‡»', 'é˜²å¾¡', 'é—ªèº²', 'æ ¼æŒ¡', 'æŒ¥èˆ', 'åŠˆç ', 'åˆºå‡º', 'çŒ›å‡»', 'é‡åˆ›', 'å‡»é£', 'è½°å‡º', 'çˆ†ç‚¸', 'è¿¸å‘', 'æ’•è£‚', 'ç ´ç¢', 'èº²é—ª', 'å†²å‘', 'æ‰‘å‘', 'è·ƒèµ·', 'ç¿»æ»š', 'æ‹›æ¶', 'åå‡»', 'æ¨ªæ‰«', 'ç›´åˆº', 'çŒ›çƒˆ', 'å‡Œå‰', 'è¿…çŒ›', 'éœ¸é“', 'ç‹‚æš´', 'æƒŠäºº', 'ææ€–', 'æ¯ç­', 'è‡´å‘½', 'ç¬é—´', 'åˆ¹é‚£', 'é¡¿æ—¶', 'è½°ç„¶', 'ç °ç„¶',
            // äº²å¯†åœºæ™¯
            'å‘»åŸ', 'å–˜æ¯', 'å¨‡å–˜', 'æ‰­åŠ¨', 'æŒºåŠ¨', 'æŠ½æ’', 'æŠšæ‘¸', 'äº²å»', 'å®å¸', 'èˆ”èˆ', 'è¿›å…¥', 'è´¯ç©¿', 'é¡¶å…¥', 'æ’å‡»', 'æ‘©æ“¦', 'äº¤åˆ', 'ç¼ ç»µ', 'èµ·ä¼', 'å¾‹åŠ¨', 'æ‰æ', 'æ‹¨å¼„', 'æ¢ç´¢', 'æ·±å…¥', 'åå', 'åŒ…è£¹', 'ç´§å’¬', 'æ”¶ç¼©', 'ç—‰æŒ›', 'å–·è–„', 'é‡Šæ”¾', 'é«˜æ½®', 'å¿«æ„Ÿ', 'èˆ’çˆ½', 'è¿·ç¦»', 'é”€é­‚', 'èµ¤è£¸', 'è£¸éœ²', 'å¨‡å«©', 'ç²‰å«©', 'é¥±æ»¡', 'æŒºç¿˜', 'ç¡•å¤§', 'ç²—é•¿', 'åšç¡¬', 'ç«çƒ­', 'æ»šçƒ«', 'æ¹¿æ¶¦'
        ])
        
        // ğŸ†• æ¨¡å‹é…ç½®
        this.modelConfig = {
            useLocalModel: false,  // âŒ å¼ºåˆ¶ç¦ç”¨æœ¬åœ°æ¨¡å‹ï¼ˆfile://åè®®ä¸‹æ— æ³•ä½¿ç”¨fetchï¼‰
            // localModelPath: '/models/paraphrase-multilingual-MiniLM-L12-v2',  // ğŸ”§ å·²æ³¨é‡Šï¼šæœ¬åœ°æ¨¡å‹åœ¨file://åè®®ä¸‹æ— æ³•åŠ è½½
            cdnModelName: 'Xenova/paraphrase-multilingual-MiniLM-L12-v2',  // âœ… ç›´æ¥ä½¿ç”¨CDNæ¨¡å‹
            useQuantized: true  // âœ… ä½¿ç”¨é‡åŒ–æ¨¡å‹ï¼šmodel_quantized.onnxï¼ˆåŠ è½½æ›´å¿«ï¼Œçº¦13MBï¼‰
        };
        
        // åˆå§‹åŒ–é»˜è®¤çš„ç³»ç»Ÿæç¤ºè¯æ¡ç›®
        this.ensureSystemPromptExists();
        const isMobile = (typeof navigator !== 'undefined') && /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
        if (isMobile) { this.modelConfig.useQuantized = true; }
        
        // é¡µé¢åˆ·æ–°åè‡ªåŠ¨é¢„åŠ è½½æ¨¡å‹ï¼ˆå¦‚æœä¹‹å‰ä½¿ç”¨çš„æ˜¯æµè§ˆå™¨æ¨¡å‹ï¼‰
        this.autoPreloadModelIfNeeded();
    }
    
    /**
     * ğŸ†• é¡µé¢åˆ·æ–°åè‡ªåŠ¨é¢„åŠ è½½æ¨¡å‹ï¼ˆå¦‚æœä¹‹å‰ä½¿ç”¨çš„æ˜¯æµè§ˆå™¨æ¨¡å‹ï¼‰
     * è¿™æ ·ç”¨æˆ·åˆ·æ–°é¡µé¢åï¼Œæ¨¡å‹ä¼šåœ¨åå°é™é»˜åŠ è½½ï¼Œä½¿ç”¨æ—¶æ— éœ€ç­‰å¾…
     */
    async autoPreloadModelIfNeeded() {
        try {
            // æ£€æŸ¥æ˜¯å¦ä¹‹å‰ä½¿ç”¨çš„æ˜¯æµè§ˆå™¨æ¨¡å‹
            const savedConfig = (typeof window !== 'undefined' && window.localStorage) 
                ? JSON.parse(window.localStorage.getItem('gameConfig') || '{}') 
                : {};
            
            const vectorMethod = savedConfig.vectorMethod || 'keyword';
            
            // å¦‚æœä¹‹å‰ä½¿ç”¨çš„æ˜¯æµè§ˆå™¨æ¨¡å‹ä¸”æ¨¡å‹å·²ç¼“å­˜è¿‡ï¼Œåˆ™é™é»˜é¢„åŠ è½½
            if (vectorMethod === 'transformers' && 
                typeof window !== 'undefined' && 
                window.localStorage && 
                window.localStorage.getItem('transformers_model_ready') === '1') {
                
                // å»¶è¿Ÿä¸€ç‚¹æ‰§è¡Œï¼Œé¿å…å½±å“é¡µé¢åˆå§‹åŒ–
                setTimeout(async () => {
                    try {
                        console.log('[è‡ªåŠ¨é¢„åŠ è½½] æ£€æµ‹åˆ°ä¹‹å‰ä½¿ç”¨æµè§ˆå™¨æ¨¡å‹ï¼Œå¼€å§‹é™é»˜é¢„åŠ è½½...');
                        
                        // ç¡®ä¿å‘é‡åŒ–æ–¹æ³•è®¾ç½®æ­£ç¡®
                        this.embeddingMethod = 'transformers';
                        
                        // é™é»˜è§¦å‘æ¨¡å‹åˆå§‹åŒ–ï¼ˆä¸æ˜¾ç¤ºåŠ è½½æç¤ºï¼‰
                        const originalDebug = window.DEBUG_TRANSFORMERS;
                        window.DEBUG_TRANSFORMERS = false; // å…³é—­è°ƒè¯•æ—¥å¿—ï¼Œä¿æŒé™é»˜
                        
                        // è§¦å‘ä¸€æ¬¡å‘é‡ç”Ÿæˆæ¥åˆå§‹åŒ–æ¨¡å‹
                        await this.getEmbeddingFromTransformers('auto preload');
                        
                        window.DEBUG_TRANSFORMERS = originalDebug; // æ¢å¤è°ƒè¯•è®¾ç½®
                        
                        console.log('[è‡ªåŠ¨é¢„åŠ è½½] âœ… æ¨¡å‹é¢„åŠ è½½å®Œæˆï¼Œåˆ·æ–°åæ— éœ€é‡æ–°ä¸‹è½½');
                        
                    } catch (error) {
                        console.log('[è‡ªåŠ¨é¢„åŠ è½½] âš ï¸ é¢„åŠ è½½å¤±è´¥ï¼Œå°†åœ¨é¦–æ¬¡ä½¿ç”¨æ—¶é‡è¯•:', error.message);
                    }
                }, 2000); // å»¶è¿Ÿ2ç§’æ‰§è¡Œ
            }
        } catch (error) {
            console.log('[è‡ªåŠ¨é¢„åŠ è½½] é…ç½®æ£€æŸ¥å¤±è´¥ï¼Œè·³è¿‡é¢„åŠ è½½');
        }
    }
    
    /**
     * ç¡®ä¿ç³»ç»Ÿæç¤ºè¯æ¡ç›®å­˜åœ¨ï¼ˆå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºï¼‰
     * æ³¨æ„ï¼šè¿™ä¸ªæ–¹æ³•åªæ˜¯æ£€æŸ¥ï¼ŒçœŸæ­£çš„åˆ›å»ºåœ¨ensureSystemPromptInKB()ä¸­
     * å› ä¸ºéœ€è¦è®¿é—®DOMå…ƒç´ ï¼ˆtextareaï¼‰
     */
    ensureSystemPromptExists() {
        // è¿™ä¸ªæ–¹æ³•ç°åœ¨åªæ˜¯ä¸€ä¸ªå ä½ç¬¦
        // çœŸæ­£çš„åˆ›å»ºé€»è¾‘åœ¨index.htmlçš„ensureSystemPromptInKB()å‡½æ•°ä¸­
        // å› ä¸ºéœ€è¦è®¿é—®DOMå…ƒç´ ï¼ˆtextareaï¼‰
    }

    /**
     * ã€æ–¹æ¡ˆ1ã€‘å…³é”®è¯æƒé‡æ³•ï¼ˆé»˜è®¤ï¼Œæ— éœ€APIï¼‰
     * ä½¿ç”¨TF-IDFæå–å…³é”®è¯ï¼Œè®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦
     * ğŸ”§ æ”¹è¿›ï¼šæ”¯æŒå­—ç¬¦çº§n-gramï¼Œè§£å†³ä¸­æ–‡åˆ†è¯é—®é¢˜
     * ğŸ”§ ä¼˜åŒ–ï¼šå¢åŠ é•¿è¯ç»„æƒé‡ï¼Œæé«˜ä¸“æœ‰åè¯åŒ¹é…å‡†ç¡®æ€§
     */
    extractKeywords(text) {
        // ğŸ”§ ä¿®å¤ï¼šç¡®ä¿textæ˜¯å­—ç¬¦ä¸²ç±»å‹
        if (typeof text !== 'string') {
            if (text === null || text === undefined) {
                return [];
            }
            // å¦‚æœæ˜¯å¯¹è±¡ï¼Œè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
            if (typeof text === 'object') {
                text = JSON.stringify(text);
            } else {
                // å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                text = String(text);
            }
        }

        const wordFreq = {};
        
        // ğŸ†• ç­–ç•¥0ï¼šæ™ºèƒ½è¯†åˆ«é•¿è¯ç»„ï¼ˆå¯èƒ½æ˜¯ä¸“æœ‰åè¯ï¼‰
        // æå–3-6å­—çš„è¿ç»­ä¸­æ–‡ï¼Œç»™äºˆæ›´é«˜æƒé‡
        const longPhrases = text.match(/[\u4e00-\u9fa5]{3,6}/g) || [];
        longPhrases.forEach(phrase => {
            // é•¿è¯ç»„æ›´å¯èƒ½æ˜¯ä¸“æœ‰åè¯ï¼Œç»™äºˆæ›´é«˜æƒé‡
            const weight = phrase.length >= 4 ? 8 : 5;
            wordFreq[phrase] = (wordFreq[phrase] || 0) + weight;
        });
        
        // ğŸ†• ç­–ç•¥1ï¼šæå–è¿ç»­ä¸­æ–‡ï¼ˆé•¿è¯ç»„ï¼Œè¢«æ ‡ç‚¹åˆ†å‰²çš„ï¼‰
        const longWords = text.match(/[\u4e00-\u9fa5]+|[a-zA-Z]+/g) || [];
        longWords.forEach(word => {
            if (word.length > 1) { // è¿‡æ»¤å•å­—
                wordFreq[word] = (wordFreq[word] || 0) + 3; // é•¿è¯æƒé‡æ›´é«˜
            }
        });
        
        // ğŸ†• ç­–ç•¥2ï¼šæå–2-3å­—n-gramï¼ˆè§£å†³"æ‰“å¬ä¸‹é’äº‘å®—"é—®é¢˜ï¼‰
        // "æ‰“å¬ä¸‹é’äº‘å®—" â†’ ["æ‰“å¬", "å¬ä¸‹", "ä¸‹é’", "é’äº‘", "äº‘å®—", "æ‰“å¬ä¸‹", "å¬ä¸‹é’", ...]
        for (let i = 0; i < text.length; i++) {
            // 2å­—è¯
            if (i + 1 < text.length) {
                const bigram = text.substring(i, i + 2);
                if (/^[\u4e00-\u9fa5]{2}$/.test(bigram)) {
                    wordFreq[bigram] = (wordFreq[bigram] || 0) + 1;
                }
            }
            // 3å­—è¯
            if (i + 2 < text.length) {
                const trigram = text.substring(i, i + 3);
                if (/^[\u4e00-\u9fa5]{3}$/.test(trigram)) {
                    wordFreq[trigram] = (wordFreq[trigram] || 0) + 2; // 3å­—è¯æƒé‡é«˜ä¸€äº›
                }
            }
        }
        
        // ğŸ†• ç­–ç•¥3ï¼šå®Œæ•´è¯è¯­ä¿æŠ¤ï¼ˆé¿å…è¢«æ‹†åˆ†ï¼‰
        // å¦‚æœä¸€ä¸ªå®Œæ•´è¯å·²ç»å­˜åœ¨ï¼Œé™ä½å…¶å­è¯çš„æƒé‡
        Object.keys(wordFreq).forEach(word => {
            if (word.length >= 4) {
                // é™ä½è¿™ä¸ªè¯çš„2å­—å­è¯æƒé‡
                for (let i = 0; i < word.length - 1; i++) {
                    const subWord = word.substring(i, i + 2);
                    if (wordFreq[subWord]) {
                        wordFreq[subWord] *= 0.5; // å­è¯æƒé‡å‡åŠ
                    }
                }
            }
        });
        
        // 3. æå–é«˜é¢‘è¯ä½œä¸ºå…³é”®è¯
        // ğŸ”¥ è¿‡æ»¤å™ªéŸ³è¯ï¼Œä¿ç•™çœŸæ­£æœ‰æ„ä¹‰çš„è¯
        const keywords = Object.entries(wordFreq)
            .filter(([word, freq]) => {
                // è¿‡æ»¤æ¡ä»¶ï¼š
                // 1. ä¸åœ¨å™ªéŸ³è¯è¡¨ä¸­
                // 2. æˆ–è€…æ˜¯é•¿è¯ï¼ˆ>=4å­—ï¼Œé€šå¸¸æ˜¯ä¸“æœ‰åè¯ï¼‰
                return !this.noiseWords.has(word) || word.length >= 4;
            })
            .sort((a, b) => b[1] - a[1])
            .slice(0, 30) // å¢åŠ åˆ°30ä¸ªå…³é”®è¯ï¼Œæé«˜è¦†ç›–ç‡
            .map(([word, freq]) => ({ word, weight: freq }));
        
        // ğŸ” è°ƒè¯•ï¼šæ˜¾ç¤ºè¿‡æ»¤æ•ˆæœ
        const allWords = Object.keys(wordFreq);
        const filteredOutWords = allWords.filter(word => 
            this.noiseWords.has(word) && word.length < 4
        );
        if (filteredOutWords.length > 0) {
            const sampleNoise = filteredOutWords.slice(0, 5).join('ã€');
            console.log(`[å…³é”®è¯æå–] è¿‡æ»¤å™ªéŸ³è¯ ${filteredOutWords.length} ä¸ªï¼ˆå¦‚ï¼š${sampleNoise}ï¼‰ï¼Œä¿ç•™ ${keywords.length} ä¸ªæœ‰æ•ˆå…³é”®è¯`);
        }
        
        return keywords;
    }

    /**
     * åˆ›å»ºç®€å•å‘é‡ï¼ˆå…³é”®è¯æƒé‡å‘é‡ï¼‰
     */
    createKeywordVector(text) {
        const keywords = this.extractKeywords(text);
        const vector = {};
        
        // æ„å»ºç¨€ç–å‘é‡
        keywords.forEach(({ word, weight }) => {
            vector[word] = weight;
        });
        
        return vector;
    }

    /**
     * è®¡ç®—ä½™å¼¦ç›¸ä¼¼åº¦ï¼ˆæ”¯æŒç¨€ç–å‘é‡å¯¹è±¡å’Œç¨ å¯†å‘é‡æ•°ç»„ï¼‰
     */
    calculateCosineSimilarity(vec1, vec2) {
        // ç©ºå€¼æ£€æŸ¥
        if (!vec1 || !vec2) {
            console.warn('[ç›¸ä¼¼åº¦è®¡ç®—] å‘é‡ä¸ºç©º');
            return 0;
        }
        
        // åˆ¤æ–­å‘é‡ç±»å‹
        const isArray1 = Array.isArray(vec1);
        const isArray2 = Array.isArray(vec2);
        
        // å¦‚æœç±»å‹ä¸åŒ¹é…ï¼Œå°è¯•è½¬æ¢
        if (isArray1 !== isArray2) {
            console.warn('[ç›¸ä¼¼åº¦è®¡ç®—] å‘é‡ç±»å‹ä¸åŒ¹é…ï¼Œå°è¯•è½¬æ¢');
            // å¦‚æœä¸€ä¸ªæ˜¯æ•°ç»„ä¸€ä¸ªæ˜¯å¯¹è±¡ï¼Œæ— æ³•æ¯”è¾ƒï¼Œè¿”å›0
            return 0;
        }
        
        if (isArray1 && isArray2) {
            // ç¨ å¯†å‘é‡ï¼ˆæ•°ç»„ï¼‰ç›¸ä¼¼åº¦è®¡ç®—
            return this.calculateArrayCosineSimilarity(vec1, vec2);
        } else {
            // ç¨€ç–å‘é‡ï¼ˆå¯¹è±¡ï¼‰ç›¸ä¼¼åº¦è®¡ç®—
            return this.calculateObjectCosineSimilarity(vec1, vec2);
        }
    }
    
    /**
     * è®¡ç®—å¯¹è±¡å½¢å¼çš„ç¨€ç–å‘é‡ç›¸ä¼¼åº¦
     */
    calculateObjectCosineSimilarity(vec1, vec2) {
        const allKeys = new Set([...Object.keys(vec1), ...Object.keys(vec2)]);
        
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        
        allKeys.forEach(key => {
            const v1 = vec1[key] || 0;
            const v2 = vec2[key] || 0;
            dotProduct += v1 * v2;
            norm1 += v1 * v1;
            norm2 += v2 * v2;
        });
        
        if (norm1 === 0 || norm2 === 0) return 0;
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }
    
    /**
     * è®¡ç®—æ•°ç»„å½¢å¼çš„ç¨ å¯†å‘é‡ç›¸ä¼¼åº¦
     */
    calculateArrayCosineSimilarity(vec1, vec2) {
        const len = Math.min(vec1.length, vec2.length);
        
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        
        for (let i = 0; i < len; i++) {
            dotProduct += vec1[i] * vec2[i];
            norm1 += vec1[i] * vec1[i];
            norm2 += vec2[i] * vec2[i];
        }
        
        if (norm1 === 0 || norm2 === 0) return 0;
        
        return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
    }

    /**
     * æ·»åŠ å¯¹è¯åˆ°å‘é‡åº“
     */
    async addConversation(userMessage, aiResponse, turnIndex, variables) {
        // ğŸ” æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒçš„ turnIndex
        const existingIndex = this.conversationEmbeddings.findIndex(
            conv => conv.turnIndex === turnIndex
        );
        
        if (existingIndex !== -1) {
            console.warn(`[å‘é‡åº“] âš ï¸ turnIndex ${turnIndex} å·²å­˜åœ¨ï¼Œå°†è¦†ç›–æ—§æ•°æ®`);
            // åˆ é™¤æ—§çš„è®°å½•
            this.conversationEmbeddings.splice(existingIndex, 1);
        }
        
        let vector;
        
        // åˆå¹¶ç”¨æˆ·æ¶ˆæ¯å’ŒAIå›å¤ä½œä¸ºä¸€ä¸ªè¯­ä¹‰å•å…ƒ
        const combinedText = `${userMessage}\n${aiResponse}`;
        
        try {
            if (this.embeddingMethod === 'keyword') {
                // æ–¹æ¡ˆ1ï¼šå…³é”®è¯å‘é‡
                vector = this.createKeywordVector(combinedText);
            } else if (this.embeddingMethod === 'api') {
                // æ–¹æ¡ˆ2ï¼šè°ƒç”¨APIè·å–embedding
                vector = await this.getEmbeddingFromAPI(combinedText);
            } else if (this.embeddingMethod === 'transformers') {
                // æ–¹æ¡ˆ3ï¼šæµè§ˆå™¨ç«¯æ¨¡å‹ï¼ˆéœ€è¦åŠ è½½transformers.jsï¼‰
                vector = await this.getEmbeddingFromTransformers(combinedText);
            } else {
                // é»˜è®¤ä½¿ç”¨å…³é”®è¯æ–¹æ³•
                console.warn(`[å‘é‡åº“] æœªçŸ¥çš„å‘é‡åŒ–æ–¹æ³•ï¼š${this.embeddingMethod}ï¼Œä½¿ç”¨å…³é”®è¯æ–¹æ³•`);
                vector = this.createKeywordVector(combinedText);
            }
            
            // éªŒè¯å‘é‡
            if (!vector || (Array.isArray(vector) && vector.length === 0) || (typeof vector === 'object' && Object.keys(vector).length === 0)) {
                console.error('[å‘é‡åº“] å‘é‡ç”Ÿæˆå¤±è´¥ï¼Œä½¿ç”¨å…³é”®è¯æ–¹æ³•ä½œä¸ºåå¤‡');
                vector = this.createKeywordVector(combinedText);
            }
        } catch (error) {
            console.error('[å‘é‡åº“] å‘é‡åŒ–å¤±è´¥:', error);
            // å›é€€åˆ°å…³é”®è¯æ–¹æ³•
            vector = this.createKeywordVector(combinedText);
        }
        
        // æå–å…³é”®ä¿¡æ¯æ‘˜è¦
        const summary = this.extractSummary(userMessage, aiResponse, variables);
        
        this.conversationEmbeddings.push({
            turnIndex: turnIndex,
            userMessage: userMessage,
            aiResponse: aiResponse,
            vector: vector,
            vectorType: Array.isArray(vector) ? 'dense' : 'sparse', // æ ‡è®°å‘é‡ç±»å‹
            summary: summary,
            timestamp: Date.now(),
            variables: this.extractImportantVariables(variables)
        });
        
        console.log(`[å‘é‡åº“] å·²æ·»åŠ ç¬¬${turnIndex}è½®å¯¹è¯ï¼ˆæ–¹æ³•ï¼š${this.embeddingMethod}ï¼‰ï¼Œå½“å‰åº“å¤§å°ï¼š${this.conversationEmbeddings.length}`);
    }

    /**
     * ğŸ†• æ·»åŠ historyæ¡ç›®åˆ°çŸ©é˜µ
     * @param {string} historyText - historyæ–‡æœ¬
     * @param {number} turnIndex - è½®æ¬¡ç´¢å¼•
     * @param {Object} variables - å½“å‰å˜é‡çŠ¶æ€
     */
    async addHistoryEntry(historyText, turnIndex, variables) {
        if (!window.matrixManager || !window.matrixManager.historyMatrix) {
            console.warn('[HistoryçŸ©é˜µ] çŸ©é˜µç®¡ç†å™¨æœªåˆå§‹åŒ–');
            return;
        }
        
        try {
            // ç”Ÿæˆå‘é‡
            let vector;
            if (this.embeddingMethod === 'keyword') {
                vector = this.createKeywordVector(historyText);
            } else if (this.embeddingMethod === 'api') {
                vector = await this.getEmbeddingFromAPI(historyText);
            } else if (this.embeddingMethod === 'transformers') {
                vector = await this.getEmbeddingFromTransformers(historyText);
            } else {
                vector = this.createKeywordVector(historyText);
            }
            
            // æ·»åŠ åˆ°historyEmbeddings
            this.historyEmbeddings.push({
                content: historyText,
                vector: vector,
                turnIndex: turnIndex,
                timestamp: Date.now(),
                variables: this.extractImportantVariables(variables)
            });
            
            // æ‘„å…¥åˆ°historyMatrix
            window.matrixManager.historyMatrix.ingestVector({
                vector: vector,
                aiResponse: historyText,  // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨aiResponseå­—æ®µè€Œä¸æ˜¯content
                turnIndex: turnIndex,
                timestamp: Date.now()
            });
            
            console.log(`[HistoryçŸ©é˜µ] âœ… å·²æ·»åŠ historyåˆ°çŸ©é˜µï¼š${historyText.substring(0, 50)}...`);
        } catch (error) {
            console.error('[HistoryçŸ©é˜µ] âŒ æ·»åŠ å¤±è´¥:', error);
        }
    }

    /**
     * æå–å¯¹è¯æ‘˜è¦ï¼ˆå…³é”®ä¿¡æ¯ï¼‰
     */
    extractSummary(userMessage, aiResponse, variables) {
        const summary = [];
        
        // æå–ç”¨æˆ·è¡ŒåŠ¨
        if (userMessage.length < 50) {
            summary.push(`ç©å®¶ï¼š${userMessage}`);
        } else {
            summary.push(`ç©å®¶ï¼š${userMessage.substring(0, 50)}...`);
        }
        
        // æå–AIå›å¤å…³é”®è¯
        const keywords = this.extractKeywords(aiResponse);
        if (keywords.length > 0) {
            const topKeywords = keywords.slice(0, 5).map(k => k.word).join('ã€');
            summary.push(`å…³é”®è¯ï¼š${topKeywords}`);
        }
        
        // æå–é‡è¦å˜é‡å˜åŒ–
        if (variables.location) {
            summary.push(`åœ°ç‚¹ï¼š${variables.location}`);
        }
        
        return summary.join(' | ');
    }

    /**
     * æå–é‡è¦å˜é‡ï¼ˆç”¨äºå¿«é€Ÿå›å¿†ï¼‰
     */
    extractImportantVariables(variables) {
        return {
            location: variables.location,
            realm: variables.realm,
            hp: variables.hp,
            mp: variables.mp,
            // åªä¿å­˜å…³é”®ä¿¡æ¯ï¼Œå‡å°‘å­˜å‚¨
            hasNewItems: variables.items && variables.items.length > 0,
            hasNewRelationships: variables.relationships && variables.relationships.length > 0
        };
    }

    /**
     * ğŸ†• æ™ºèƒ½æ£€æµ‹å‘é‡åº“çš„ä¸»è¦å‘é‡ç±»å‹
     */
    detectVectorType() {
        if (this.conversationEmbeddings.length === 0) return 'keyword';
        
        // ç»Ÿè®¡å‘é‡ç±»å‹
        const typeCounts = {
            dense: 0,  // ç¨ å¯†å‘é‡ï¼ˆæ•°ç»„ï¼‰
            sparse: 0  // ç¨€ç–å‘é‡ï¼ˆå¯¹è±¡ï¼‰
        };
        
        this.conversationEmbeddings.forEach(conv => {
            if (Array.isArray(conv.vector)) {
                typeCounts.dense++;
            } else if (typeof conv.vector === 'object') {
                typeCounts.sparse++;
            }
        });
        
        // è¿”å›å æ¯”æœ€å¤§çš„ç±»å‹
        return typeCounts.dense > typeCounts.sparse ? 'dense' : 'sparse';
    }

    /**
     * æ£€ç´¢ç›¸å…³ä¸Šä¸‹æ–‡ï¼ˆæ™ºèƒ½å…¼å®¹ç‰ˆï¼‰
     */
    async retrieveRelevantContext(currentInput, recentHistory = []) {
        if (this.conversationEmbeddings.length === 0) {
            return {
                relevantChunks: [],
                recentChunks: recentHistory
            };
        }
        
        try {
            // ğŸ†• 1. æ™ºèƒ½æ£€æµ‹å‘é‡åº“ç±»å‹
            const vectorLibType = this.detectVectorType();
            console.log(`[å‘é‡æ£€ç´¢] å‘é‡åº“ç±»å‹ï¼š${vectorLibType}ï¼Œå½“å‰æ–¹æ³•ï¼š${this.embeddingMethod}`);
            
            // ğŸ†• 2. æ ¹æ®å‘é‡åº“ç±»å‹å’Œå½“å‰è®¾ç½®ï¼Œæ™ºèƒ½é€‰æ‹©æ£€ç´¢ç­–ç•¥
            let currentVector;
            let useArrayVector = false;  // æ ‡è®°æ˜¯å¦ä½¿ç”¨æ•°ç»„å‘é‡
            
            if (vectorLibType === 'dense' && this.embeddingMethod !== 'keyword') {
                // å‘é‡åº“æ˜¯ç¨ å¯†å‘é‡ï¼Œä¸”å½“å‰ä¸æ˜¯å…³é”®è¯æ¨¡å¼
                // ç­–ç•¥ï¼šå°è¯•ç”Ÿæˆç¨ å¯†å‘é‡ï¼Œå¤±è´¥åˆ™é™çº§åˆ°å…³é”®è¯
                console.log('[å‘é‡æ£€ç´¢] å°è¯•ç”Ÿæˆç¨ å¯†å‘é‡...');
                
                try {
                    if (this.embeddingMethod === 'api') {
                        // è°ƒç”¨APIç”Ÿæˆå‘é‡
                        currentVector = await this.getEmbeddingFromAPI(currentInput);
                        useArrayVector = true;
                        console.log('[å‘é‡æ£€ç´¢] âœ… ä½¿ç”¨APIç”Ÿæˆç¨ å¯†å‘é‡');
                    } else if (this.embeddingMethod === 'transformers') {
                        // è°ƒç”¨æµè§ˆå™¨ç«¯æ¨¡å‹ç”Ÿæˆå‘é‡
                        currentVector = await this.getEmbeddingFromTransformers(currentInput);
                        useArrayVector = true;
                        console.log('[å‘é‡æ£€ç´¢] âœ… ä½¿ç”¨Transformersç”Ÿæˆç¨ å¯†å‘é‡');
                    } else {
                        // æœªçŸ¥æ–¹æ³•ï¼Œé™çº§
                        throw new Error('æœªçŸ¥çš„å‘é‡åŒ–æ–¹æ³•');
                    }
                    
                    // éªŒè¯å‘é‡æ˜¯å¦æœ‰æ•ˆ
                    if (!currentVector || !Array.isArray(currentVector) || currentVector.length === 0) {
                        throw new Error('ç”Ÿæˆçš„å‘é‡æ— æ•ˆ');
                    }
                } catch (error) {
                    // ç”Ÿæˆå¤±è´¥ï¼Œé™çº§åˆ°å…³é”®è¯æ–¹æ³•
                    console.warn('[å‘é‡æ£€ç´¢] âš ï¸ ç¨ å¯†å‘é‡ç”Ÿæˆå¤±è´¥ï¼Œé™çº§ä½¿ç”¨å…³é”®è¯æ–¹æ³•:', error.message);
                    currentVector = this.createKeywordVector(currentInput);
                    useArrayVector = false;
                }
            } else {
                // é»˜è®¤ä½¿ç”¨å…³é”®è¯æ–¹æ³•ï¼ˆæœ€å…¼å®¹ï¼‰
                currentVector = this.createKeywordVector(currentInput);
                useArrayVector = false;
            }
            
            // éªŒè¯å‘é‡
            if (!currentVector || (Array.isArray(currentVector) ? currentVector.length === 0 : Object.keys(currentVector).length === 0)) {
                console.warn('[å‘é‡æ£€ç´¢] å½“å‰è¾“å…¥å‘é‡ä¸ºç©ºï¼Œè·³è¿‡æ£€ç´¢');
                return {
                    relevantChunks: [],
                    recentChunks: recentHistory
                };
            }
            
            // ğŸ†• 3. è·å–å½“å‰æœ€å¤§è½®æ¬¡ï¼ˆç”¨äºæ’é™¤è¿‘æœŸå¯¹è¯ï¼‰
            const currentMaxTurn = Math.max(...this.conversationEmbeddings.map(conv => conv.turnIndex));
            const minAllowedTurn = currentMaxTurn - this.minTurnGap;
            console.log(`[å‘é‡æ£€ç´¢] å½“å‰æœ€å¤§è½®æ¬¡ï¼š${currentMaxTurn}ï¼Œè¿œæœŸè®°å¿†é˜ˆå€¼ï¼šç¬¬${minAllowedTurn}è½®ä¹‹å‰`);
            
            // ğŸ†• 4. æ™ºèƒ½è®¡ç®—ç›¸ä¼¼åº¦ï¼ˆæ”¯æŒæ··åˆå‘é‡ç±»å‹ï¼‰
            const similarities = this.conversationEmbeddings.map((conv, index) => {
                let convVector = conv.vector;
                let similarity = 0;
                
                const isConvArray = Array.isArray(conv.vector);
                const isCurrArray = Array.isArray(currentVector);
                
                if (isConvArray === isCurrArray) {
                    // ç±»å‹åŒ¹é…ï¼Œç›´æ¥è®¡ç®—
                    similarity = this.calculateCosineSimilarity(currentVector, convVector);
                } else {
                    // ğŸ†• ç±»å‹ä¸åŒ¹é…ï¼Œæ™ºèƒ½è½¬æ¢
                    if (isConvArray && !isCurrArray) {
                        // åº“ä¸­æ˜¯æ•°ç»„ï¼Œå½“å‰æ˜¯å¯¹è±¡ -> å°†åº“ä¸­å‘é‡è½¬ä¸ºå…³é”®è¯å‘é‡
                        convVector = this.createKeywordVector(conv.userMessage + '\n' + conv.aiResponse);
                        similarity = this.calculateCosineSimilarity(currentVector, convVector);
                    } else if (!isConvArray && isCurrArray) {
                        // åº“ä¸­æ˜¯å¯¹è±¡ï¼Œå½“å‰æ˜¯æ•°ç»„ -> å°†åº“ä¸­å‘é‡è½¬ä¸ºæ•°ç»„ï¼ˆæš‚ä¸æ”¯æŒï¼Œè¿”å›ä½ç›¸ä¼¼åº¦ï¼‰
                        console.warn(`[å‘é‡æ£€ç´¢] ç¬¬${conv.turnIndex}è½®å‘é‡ç±»å‹ä¸å…¼å®¹ï¼Œè·³è¿‡`);
                        similarity = 0;
                    }
                }
                
                return {
                    index: index,
                    turnIndex: conv.turnIndex,
                    similarity: similarity,
                    conversation: conv,
                    vectorType: isConvArray ? 'dense' : 'sparse'
                };
            });
            
            // 5. è¿‡æ»¤å¹¶æ’åºï¼šã€è¿œæœŸè®°å¿†ã€‘æ’é™¤æœ€è¿‘Nè½®å¯¹è¯
            // ğŸ”¥ ä¸å†ä½¿ç”¨ç›¸ä¼¼åº¦é˜ˆå€¼è¿‡æ»¤ï¼Œå¼ºåˆ¶è¿”å›æŒ‡å®šæ•°é‡
            let candidateConversations = similarities
                .filter(item => item.turnIndex <= minAllowedTurn) // ğŸ†• åªä¿ç•™è‡³å°‘minTurnGapè½®ä¹‹å¤–çš„å¯¹è¯
                .sort((a, b) => b.similarity - a.similarity);
            
            // ğŸ†• 6. é™åˆ¶åŠ¨æ€ä¸–ç•Œæ¶ˆæ¯ï¼šæœ€å¤šåªä¿ç•™1æ¡ç›¸ä¼¼åº¦æœ€é«˜çš„åŠ¨æ€ä¸–ç•Œæ¶ˆæ¯
            // ğŸ” è°ƒè¯•ï¼šæ‰“å°å€™é€‰å¯¹è¯åˆ—è¡¨
            console.log(`[å‘é‡æ£€ç´¢-è°ƒè¯•] è¿œæœŸè®°å¿†å€™é€‰æ•°é‡ï¼š${candidateConversations.length}æ¡`);
            candidateConversations.slice(0, 5).forEach((item, idx) => {
                const userMsgPreview = item.conversation.userMessage ? item.conversation.userMessage.substring(0, 50) : 'undefined';
                console.log(`  å€™é€‰${idx + 1}: ç¬¬${item.turnIndex}è½® ç›¸ä¼¼åº¦${item.similarity.toFixed(3)} ç”¨æˆ·æ¶ˆæ¯: ${userMsgPreview}...`);
            });
            
            const dynamicWorldItems = candidateConversations.filter(item => 
                item.conversation.userMessage && item.conversation.userMessage.startsWith('[åŠ¨æ€ä¸–ç•Œ]')
            );
            const normalItems = candidateConversations.filter(item => 
                !item.conversation.userMessage || !item.conversation.userMessage.startsWith('[åŠ¨æ€ä¸–ç•Œ]')
            );
            
            console.log(`[å‘é‡æ£€ç´¢-è°ƒè¯•] åˆ†ç±»ç»“æœ - åŠ¨æ€ä¸–ç•Œ:${dynamicWorldItems.length}æ¡, æ­£å¸¸å¯¹è¯:${normalItems.length}æ¡`);
            
            // ğŸ”¥ å¼ºåˆ¶è¿”å› maxRetrieveCount - 1 æ¡ï¼šæœ€å¤š1æ¡åŠ¨æ€ä¸–ç•Œ + å‰©ä½™åé¢ç»™æ­£å¸¸å¯¹è¯
            const targetCount = Math.max(1, this.maxRetrieveCount - 1); // è‡³å°‘1æ¡
            const maxNormalCount = targetCount - Math.min(1, dynamicWorldItems.length); // æ­£å¸¸å¯¹è¯çš„åé¢
            
            const relevantConversations = [
                ...normalItems.slice(0, maxNormalCount),  // æ­£å¸¸å¯¹è¯å¡«æ»¡å‰©ä½™åé¢
                ...dynamicWorldItems.slice(0, 1)  // æœ€å¤š1æ¡åŠ¨æ€ä¸–ç•Œ
            ].sort((a, b) => b.similarity - a.similarity); // é‡æ–°æŒ‰ç›¸ä¼¼åº¦æ’åº
            
            // ğŸ†• ç»Ÿè®¡å‘é‡ç±»å‹ä¿¡æ¯
            const denseCount = similarities.filter(s => s.vectorType === 'dense').length;
            const sparseCount = similarities.filter(s => s.vectorType === 'sparse').length;
            const excludedRecentCount = similarities.filter(item => item.turnIndex > minAllowedTurn).length;
            const dynamicWorldCount = dynamicWorldItems.length;
            const normalCount = normalItems.length;
            
            console.log(`â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`);
            console.log(`â•‘  ğŸ” å‘é‡æ£€ç´¢æ‰§è¡ŒæŠ¥å‘Š                            â•‘`);
            console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
            console.log(`â•‘  ğŸ“Š å‘é‡åº“ç»Ÿè®¡ï¼š                                â•‘`);
            console.log(`â•‘    - æ€»è®°å½•æ•°ï¼š${this.conversationEmbeddings.length}è½®                          â•‘`);
            console.log(`â•‘    - ç¨ å¯†å‘é‡ï¼ˆDenseï¼‰ï¼š${denseCount}è½®                    â•‘`);
            console.log(`â•‘    - ç¨€ç–å‘é‡ï¼ˆSparseï¼‰ï¼š${sparseCount}è½®                   â•‘`);
            console.log(`â•‘  ğŸ¯ è¿œæœŸè®°å¿†è¿‡æ»¤ï¼š                              â•‘`);
            console.log(`â•‘    - æœ€å°è½®æ¬¡é—´éš”ï¼š${this.minTurnGap}è½®                     â•‘`);
            console.log(`â•‘    - æ’é™¤è¿‘æœŸå¯¹è¯ï¼š${excludedRecentCount}è½®ï¼ˆç¬¬${minAllowedTurn + 1}-${currentMaxTurn}è½®ï¼‰ â•‘`);
            console.log(`â•‘  ğŸ¯ åŠ¨æ€ä¸–ç•Œé™åˆ¶ï¼š                              â•‘`);
            console.log(`â•‘    - åŒ¹é…åˆ°åŠ¨æ€ä¸–ç•Œï¼š${dynamicWorldCount}æ¡                        â•‘`);
            console.log(`â•‘    - ä¿ç•™åŠ¨æ€ä¸–ç•Œï¼š${Math.min(1, dynamicWorldItems.length)}æ¡ï¼ˆé™åˆ¶æœ€å¤š1æ¡ï¼‰              â•‘`);
            console.log(`â•‘    - åŒ¹é…åˆ°æ­£å¸¸å¯¹è¯ï¼š${normalCount}æ¡                        â•‘`);
            console.log(`â•‘  ğŸ¯ æ£€ç´¢ç»“æœï¼ˆå¼ºåˆ¶è¿”å›ï¼‰ï¼š                        â•‘`);
            console.log(`â•‘    - æ£€ç´¢æ–¹æ³•ï¼š${vectorLibType === 'dense' ? 'å…³é”®è¯é™çº§' : 'å…³é”®è¯åŒ¹é…'}         â•‘`);
            console.log(`â•‘    - ç›®æ ‡æ•°é‡ï¼š${targetCount}æ¡ï¼ˆé…ç½®-1ï¼‰                  â•‘`);
            console.log(`â•‘    - å®é™…è¿”å›ï¼š${relevantConversations.length}æ¡                            â•‘`);
            console.log(`â•‘    - ä¸å—ç›¸ä¼¼åº¦é˜ˆå€¼é™åˆ¶                          â•‘`);
            console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
            
            relevantConversations.forEach(item => {
                const typeTag = item.vectorType === 'dense' ? '[ç¨ å¯†â†’è½¬æ¢]' : '[ç¨€ç–]';
                const isDynamicWorld = item.conversation.userMessage && item.conversation.userMessage.startsWith('[åŠ¨æ€ä¸–ç•Œ]');
                const worldTag = isDynamicWorld ? 'ğŸŒ' : 'ğŸ’¬';
                console.log(`  ${worldTag} ${typeTag} ç¬¬${item.turnIndex}è½® ç›¸ä¼¼åº¦:${item.similarity.toFixed(3)} ${item.conversation.summary}`);
            });
            
            // 4. æ ¼å¼åŒ–ä¸ºä¸Šä¸‹æ–‡
            const relevantChunks = relevantConversations.map(item => ({
                turnIndex: item.turnIndex,
                userMessage: item.conversation.userMessage,
                aiResponse: item.conversation.aiResponse,
                similarity: item.similarity,
                summary: item.conversation.summary
            }));
            
            return {
                relevantChunks: relevantChunks,
                recentChunks: recentHistory
            };
            
        } catch (error) {
            console.error('[å‘é‡æ£€ç´¢] æ£€ç´¢å¤±è´¥:', error);
            return {
                relevantChunks: [],
                recentChunks: recentHistory
            };
        }
    }

    /**
     * æ£€ç´¢ç›¸å…³å†…å®¹ï¼ˆç®€åŒ–æ¥å£ï¼Œä¾›æ‰‹æœºç«¯APIè°ƒç”¨ï¼‰
     * @param {string} query - æŸ¥è¯¢æ–‡æœ¬
     * @param {number} count - è¿”å›æ•°é‡
     * @param {string} type - æ£€ç´¢ç±»å‹ ('conversation' | 'history')
     * @returns {Array} - ç›¸å…³ç»“æœæ•°ç»„
     */
    async retrieveRelevant(query, count = 3, type = 'conversation') {
        try {
            // ä¸´æ—¶è®¾ç½®æ£€ç´¢æ•°é‡
            const originalMaxCount = this.maxRetrieveCount;
            this.maxRetrieveCount = count;
            
            const result = await this.retrieveRelevantContext(query, []);
            
            // æ¢å¤åŸè®¾ç½®
            this.maxRetrieveCount = originalMaxCount;
            
            return result.relevantChunks || [];
        } catch (error) {
            console.error('[retrieveRelevant] æ£€ç´¢å¤±è´¥:', error);
            return [];
        }
    }

    /**
     * æ„å»ºä¼˜åŒ–åçš„ä¸Šä¸‹æ–‡æ¶ˆæ¯ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
     * ä¼˜å…ˆçº§é¡ºåºï¼ˆä»é«˜åˆ°ä½ï¼‰ï¼š
     * P0   - JSONæ ¼å¼è§„åˆ™ï¼ˆæœ€é«˜å…³æ³¨ï¼‰
     * P1   - å½“å‰å˜é‡çŠ¶æ€ï¼ˆæœ€é«˜å…³æ³¨ï¼‰
     * P2   - æœ€è¿‘å¯¹è¯å†å²ï¼ˆå‰§æƒ…è¿è´¯æ€§ï¼‰
     * P2.5 - å¸¸é©»çŸ¥è¯†åº“ã€é‡ç‚¹ã€‘ï¼ˆé«˜ä¼˜å…ˆçº§å‚è€ƒï¼‰
     * P3   - å‘é‡æ£€ç´¢ï¼šå†å²è®°å¿†ï¼ˆè¿œæœŸè®°å¿†ï¼‰
     * P3.5 - å¸¸é©»çŸ¥è¯†åº“ã€æ¬¡é‡ç‚¹ã€‘ï¼ˆä¸­ä¼˜å…ˆçº§å‚è€ƒï¼‰
     * P4   - å‘é‡æ£€ç´¢ï¼šçŸ¥è¯†åº“ï¼ˆç›¸å…³çŸ¥è¯†ï¼‰
     * P5   - å¸¸é©»çŸ¥è¯†åº“ã€éé‡ç‚¹ã€‘ï¼ˆä½ä¼˜å…ˆçº§å‚è€ƒï¼‰
     * P6   - å½“å‰ç”¨æˆ·è¾“å…¥ï¼ˆæœ«å°¾å¼ºåŒ–ï¼‰
     */
    async buildOptimizedMessages(systemPrompt, currentVariables, currentInput, historyDepth = 3, fullConversationHistory = [], retrievalInput = null) {
        const messages = [];
        
        // ğŸ¯ ã€ç»å¯¹æœ€é«˜ä¼˜å…ˆçº§ã€‘å™äº‹è§†è§’ - å§‹ç»ˆæ”¾åœ¨ç¬¬ä¸€ä¸ªæ¶ˆæ¯
        // ä»å…¨å±€è·å–å™äº‹è§†è§’è®¾ç½®
        const narrativePerspective = window.currentNarrativePerspective || 'first';
        const perspectivePrompts = {
            'first': 'ã€æå…¶é‡è¦ã€‘å™äº‹è§†è§’å¼ºåˆ¶è¦æ±‚ï¼šæ•…äº‹æå†™éœ€è¦ä»¥ä¸»è§’ç¬¬ä¸€äººç§°è§†è§’ä¸ºä¸»ï¼Œå…è®¸è‡ªç„¶å™è¿°ä¸å¯¹è¯',
            'second': 'ã€æå…¶é‡è¦ã€‘å™äº‹è§†è§’å¼ºåˆ¶è¦æ±‚ï¼šæ•…äº‹æå†™éœ€è¦ä»¥ä¸»è§’ç¬¬äºŒäººç§°è§†è§’ä¸ºä¸»ï¼Œå…è®¸è‡ªç„¶å™è¿°ä¸å¯¹è¯',
            'third': 'ã€æå…¶é‡è¦ã€‘å™äº‹è§†è§’å¼ºåˆ¶è¦æ±‚ï¼šæ•…äº‹æå†™éœ€è¦ä»¥ä¸»è§’ç¬¬ä¸‰äººç§°è§†è§’ä¸ºä¸»ï¼Œå…è®¸è‡ªç„¶å™è¿°ä¸å¯¹è¯'
        };
        
        messages.push({
            role: 'system',
            content: perspectivePrompts[narrativePerspective]
        });
        console.log('[å™äº‹è§†è§’] å·²æ·»åŠ åˆ°å‘é‡æ£€ç´¢æ¨¡å¼çš„æœ€é¡¶éƒ¨:', perspectivePrompts[narrativePerspective].substring(0, 50) + '...');
        
        // ğŸ” è°ƒè¯•ï¼šè¿½è¸ªå‚æ•°ä¼ é€’
        console.log(`[buildOptimizedMessages] å‚æ•°è¿½è¸ªï¼š`);
        console.log(`  - currentInputé•¿åº¦: ${currentInput.length}`);
        console.log(`  - retrievalInput: ${retrievalInput ? retrievalInput.substring(0, 50) : 'null/undefined'}`);
        
        // ğŸ”§ é¢„å¤„ç†ï¼šæå–å¹¶åˆ†ç»„å¸¸é©»çŸ¥è¯†åº“
        const alwaysIncludeKnowledge = this.staticKnowledgeBase.filter(
            item => item.alwaysInclude === true && item.id !== 'system_prompt_main'
        );
        const topPriorityKB = alwaysIncludeKnowledge.filter(item => item.priority === 'top');
        const highPriorityKB = alwaysIncludeKnowledge.filter(item => item.priority === 'high');
        const mediumPriorityKB = alwaysIncludeKnowledge.filter(item => item.priority === 'medium');
        const lowPriorityKB = alwaysIncludeKnowledge.filter(item => !item.priority || item.priority === 'low');
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P0ã€ç»å¯¹æœ€é«˜ä¼˜å…ˆçº§ã€‘ä¿®ä»™æ¸¸æˆè§„åˆ™ - ç‹¬å æœ€é¡¶éƒ¨
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        if (topPriorityKB.length > 0) {
            topPriorityKB.forEach((item, index) => {
                // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
                let contentText = item.content;
                if (typeof item.content === 'object' && item.content !== null) {
                    contentText = JSON.stringify(item.content, null, 2);
                }
                messages.push({
                    role: 'system',
                    content: `ã€ğŸ‘‘ ${item.title}ã€‘\n\n${contentText}`
                });
                console.log(`[å¸¸é©»çŸ¥è¯†-é¡¶éƒ¨] å·²æ³¨å…¥é¡¶éƒ¨çŸ¥è¯†ï¼š${item.title}`);
            });
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P0.5ã€ç³»ç»Ÿæç¤ºè¯ã€‘æ¸¸æˆç³»ç»Ÿæç¤ºè¯ï¼ˆåŸºç¡€ï¼‰
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        let finalSystemPrompt = systemPrompt;
        
        const systemPromptItem = this.staticKnowledgeBase.find(item => item.id === 'system_prompt_main');
        if (systemPromptItem) {
            finalSystemPrompt = systemPromptItem.content;
            console.log('[ç³»ç»Ÿæç¤ºè¯] ä½¿ç”¨çŸ¥è¯†åº“ä¸­çš„ç³»ç»Ÿæç¤ºè¯ï¼ˆå¯åœ¨çŸ¥è¯†åº“ä¸­ç¼–è¾‘ï¼‰');
        } else {
            console.log('[ç³»ç»Ÿæç¤ºè¯] ä½¿ç”¨é»˜è®¤ç³»ç»Ÿæç¤ºè¯ï¼ˆæœªæ‰¾åˆ°çŸ¥è¯†åº“æ¡ç›®ï¼‰');
        }
        
        messages.push({
            role: 'system',
            content: finalSystemPrompt
        });
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P1ã€æœ€é«˜ä¼˜å…ˆçº§ã€‘å½“å‰å˜é‡çŠ¶æ€
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // ğŸ†• ä»å˜é‡ä¸­ç§»é™¤historyå­—æ®µï¼ˆhistoryå°†å•ç‹¬å‘é€ï¼‰
        const variablesWithoutHistory = { ...currentVariables };
        delete variablesWithoutHistory.history;
        
        messages.push({
            role: 'system',
            content: 'å½“å‰è§’è‰²å˜é‡çŠ¶æ€ï¼š\n```json\n' + JSON.stringify(variablesWithoutHistory, null, 2) + '\n```'
        });
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P1.5ã€é«˜ä¼˜å…ˆçº§ã€‘Historyä¸“ç”¨ä¸Šä¸‹æ–‡ï¼ˆ30æ¡æœ€è¿‘ + 15æ¡çŸ©é˜µæ£€ç´¢ï¼‰
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        let matrixRecentCount = 0;
        let matrixRetrievedCount = 0;
        
        if (this.historyEmbeddings.length > 0) {
            // ä½¿ç”¨ç”¨æˆ·çš„æŸ¥è¯¢æ„å»ºhistoryä¸Šä¸‹æ–‡
            const historyQuery = retrievalInput || this.extractCoreQuery(currentInput);
            const historyContext = await this.buildHistoryContext(historyQuery);
            
            // è®°å½•çŸ©é˜µæ£€ç´¢æ•°æ®ç”¨äºæŠ¥å‘Š
            matrixRecentCount = historyContext.recent.length;
            matrixRetrievedCount = historyContext.matrix.length;
            
            // æ„å»ºhistoryæ¶ˆæ¯
            let historyMessage = 'ã€è§’è‰²å†å²è®°å½•ï¼ˆHistoryï¼‰ã€‘\n\n';
            
            // æœ€è¿‘çš„historyï¼ˆæŒ‰æ—¶é—´é¡ºåºï¼Œæœ€æ–°çš„åœ¨æœ€åï¼‰
            if (historyContext.recent.length > 0) {
                historyMessage += `ğŸ“… æœ€è¿‘${historyContext.recent.length}æ¡è®°å½•ï¼ˆæ—¶é—´é¡ºåºï¼‰ï¼š\n`;
                // åè½¬æ•°ç»„ï¼Œä½¿æœ€æ–°çš„åœ¨æœ€å
                const recentReversed = [...historyContext.recent].reverse();
                recentReversed.forEach((h, i) => {
                    historyMessage += `${i + 1}. ${h}\n`;
                });
                historyMessage += '\n';
            }
            
            // çŸ©é˜µæ£€ç´¢çš„ç›¸å…³history
            if (historyContext.matrix.length > 0) {
                historyMessage += `ğŸ” ç›¸å…³å†å²${historyContext.matrix.length}æ¡ï¼ˆæ™ºèƒ½æ£€ç´¢ï¼‰ï¼š\n`;
                historyContext.matrix.forEach((h, i) => {
                    historyMessage += `${i + 1}. ${h}\n`;
                });
            }
            
            if (historyContext.recent.length > 0 || historyContext.matrix.length > 0) {
                messages.push({
                    role: 'system',
                    content: historyMessage
                });
                console.log(`[Historyä¸Šä¸‹æ–‡-P1.5] å·²æ·»åŠ  æœ€è¿‘${historyContext.recent.length}æ¡ + çŸ©é˜µæ£€ç´¢${historyContext.matrix.length}æ¡`);
            }
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P2ã€ä¸­é—´é å‰ã€‘æœ€è¿‘å¯¹è¯ï¼ˆè¿‘æœŸè®°å¿†ï¼‰- åªä¿ç•™AIå›å¤ï¼Œå‰§æƒ…è¿è´¯æ€§æœ€å¼º
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        const conversationHistory = fullConversationHistory.length > 0 
            ? fullConversationHistory 
            : (window.gameState?.conversationHistory || []);
        
        let filteredHistory = [];
        if (conversationHistory.length > 0 && historyDepth > 0) {
            const recentHistory = conversationHistory.slice(-historyDepth * 2);
            
            // ğŸ†• è¿‡æ»¤æ‰ç”¨æˆ·æ¶ˆæ¯ï¼Œåªä¿ç•™AIå›å¤ï¼ˆä¿æŒå‰§æƒ…è¿è´¯æ€§ï¼‰
            filteredHistory = recentHistory.filter(msg => msg.role === 'assistant');
            
            if (filteredHistory.length > 0) {
                messages.push(...filteredHistory);
                console.log(`[è¿‘æœŸè®°å¿†-P2] æ·»åŠ æœ€è¿‘${filteredHistory.length}æ¡AIå›å¤ï¼ˆå·²è¿‡æ»¤ç”¨æˆ·è¾“å…¥ï¼‰`);
            }
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P2.5ã€ä¸­é—´é å‰ã€‘å¸¸é©»çŸ¥è¯†åº“ã€é‡ç‚¹ã€‘- é«˜ä¼˜å…ˆçº§å‚è€ƒ
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        if (highPriorityKB.length > 0) {
            let highContext = 'ã€â­ é‡ç‚¹å¸¸é©»çŸ¥è¯†ã€‘ä»¥ä¸‹çŸ¥è¯†é«˜åº¦é‡è¦ï¼Œè¯·ä¼˜å…ˆå‚è€ƒï¼š\n\n';
            
            highPriorityKB.forEach((item, index) => {
                // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
                let contentText = item.content;
                if (typeof item.content === 'object' && item.content !== null) {
                    contentText = JSON.stringify(item.content, null, 2);
                }
                highContext += `â­ é‡ç‚¹${index + 1}ï¼ˆ${item.category} - ${item.title}ï¼‰ï¼š\n`;
                highContext += `${contentText}\n\n`;
            });
            
            messages.push({
                role: 'system',
                content: highContext
            });
            console.log(`[å¸¸é©»çŸ¥è¯†-é‡ç‚¹] å·²æ³¨å…¥ ${highPriorityKB.length} æ¡é‡ç‚¹çŸ¥è¯†`);
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P3ã€ä¸­é—´ã€‘å‘é‡æ£€ç´¢ï¼šå¯¹è¯å†å²ï¼ˆè¿œæœŸè®°å¿†ï¼‰
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        let inputForRetrieval;
        if (retrievalInput) {
            inputForRetrieval = retrievalInput;
            console.log(`[å‘é‡æ£€ç´¢] ä½¿ç”¨ä¼ å…¥çš„retrievalInput`);
        } else {
            inputForRetrieval = this.extractCoreQuery(currentInput);
            console.log(`[å‘é‡æ£€ç´¢] ä½¿ç”¨extractCoreQueryæå–`);
        }
        
        // ğŸ†• å¦‚æœé…ç½®äº†åŒ…å«æœ€è¿‘AIå›å¤ï¼Œåˆ™å°†å®ƒä»¬åˆå¹¶åˆ°æŸ¥è¯¢ä¸­
        if (this.includeRecentAIRepliesInQuery > 0) {
            const conversationHistory = fullConversationHistory.length > 0 
                ? fullConversationHistory 
                : (window.gameState?.conversationHistory || []);
            
            if (conversationHistory.length > 0) {
                // æå–æœ€è¿‘Nè½®çš„AIå›å¤
                const recentAIReplies = conversationHistory
                    .filter(msg => msg.role === 'assistant')
                    .slice(-this.includeRecentAIRepliesInQuery)
                    .map(msg => msg.content);
                
                if (recentAIReplies.length > 0) {
                    // ğŸ”¥ ç­–ç•¥ï¼šé‡å¤ç”¨æˆ·è¾“å…¥3æ¬¡ + å™ªéŸ³è¯è¿‡æ»¤ï¼Œæé«˜ç²¾å‡†åº¦
                    // ç”±äºå·²ç»æœ‰å™ªéŸ³è¯è¿‡æ»¤ï¼Œä¸éœ€è¦é‡å¤å¤ªå¤šæ¬¡
                    const combinedQuery = 
                        inputForRetrieval + '\n' +           // ç”¨æˆ·è¾“å…¥ï¼ˆç¬¬1æ¬¡ï¼‰
                        recentAIReplies.join('\n') + '\n' +  // AIå›å¤ï¼ˆå®Œæ•´ï¼Œä½†å™ªéŸ³è¯ä¼šè¢«è¿‡æ»¤ï¼‰
                        inputForRetrieval + '\n' +           // ç”¨æˆ·è¾“å…¥ï¼ˆç¬¬2æ¬¡ï¼‰
                        inputForRetrieval;                   // ç”¨æˆ·è¾“å…¥ï¼ˆç¬¬3æ¬¡ï¼‰
                    
                    inputForRetrieval = combinedQuery;
                    console.log(`[å‘é‡æ£€ç´¢] âœ… å·²åŒ…å«æœ€è¿‘${recentAIReplies.length}è½®AIå›å¤ï¼Œç”¨æˆ·è¾“å…¥é‡å¤3æ¬¡ï¼Œå™ªéŸ³è¯å·²è¿‡æ»¤`);
                }
            }
        }
        
        console.log(`[å‘é‡æ£€ç´¢] æœ€ç»ˆæ£€ç´¢æ–‡æœ¬ï¼š${inputForRetrieval.substring(0, 50)}...`);
        
        // ğŸ” æ˜¾ç¤ºæå–çš„æœ‰æ•ˆå…³é”®è¯ï¼ˆå¸®åŠ©ç†è§£æ£€ç´¢æ•ˆæœï¼‰
        const queryKeywords = this.extractKeywords(inputForRetrieval);
        if (queryKeywords.length > 0) {
            const topKeywords = queryKeywords.slice(0, 10).map(k => k.word).join('ã€');
            console.log(`[å‘é‡æ£€ç´¢] æœ‰æ•ˆå…³é”®è¯ï¼ˆå‰10ä¸ªï¼‰ï¼š${topKeywords}`);
        }
        
        const retrievalResult = await this.retrieveRelevantContext(inputForRetrieval, []);
        
        if (retrievalResult.relevantChunks.length > 0) {
            let relevantContext = 'ã€ç›¸å…³å†å²å›å¿†ã€‘ä»¥ä¸‹æ˜¯ä¸å½“å‰æƒ…å¢ƒç›¸å…³çš„è¿‡å¾€è®°å¿†ï¼š\n\n';
            
            retrievalResult.relevantChunks.forEach((chunk, index) => {
                relevantContext += `è®°å¿†${index + 1}ï¼ˆç¬¬${chunk.turnIndex}è½®å¯¹è¯ï¼Œç›¸ä¼¼åº¦${(chunk.similarity * 100).toFixed(1)}%ï¼‰ï¼š\n`;
                relevantContext += `- ç©å®¶è¡ŒåŠ¨ï¼š${chunk.userMessage}\n`;
                // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨å®Œæ•´çš„AIå›å¤è€Œä¸æ˜¯æ‘˜è¦
                relevantContext += `- AIå›å¤ï¼š${chunk.aiResponse || chunk.summary}\n\n`;
            });
            
            messages.push({
                role: 'system',
                content: relevantContext
            });
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P3.5ã€ä¸­é—´ã€‘å¸¸é©»çŸ¥è¯†åº“ã€æ¬¡é‡ç‚¹ã€‘- ä¸­ä¼˜å…ˆçº§å‚è€ƒ
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        if (mediumPriorityKB.length > 0) {
            let mediumContext = 'ã€ğŸ“Œ æ¬¡é‡ç‚¹å¸¸é©»çŸ¥è¯†ã€‘ä»¥ä¸‹çŸ¥è¯†è¾ƒä¸ºé‡è¦ï¼š\n\n';
            
            mediumPriorityKB.forEach((item, index) => {
                // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
                let contentText = item.content;
                if (typeof item.content === 'object' && item.content !== null) {
                    contentText = JSON.stringify(item.content, null, 2);
                }
                mediumContext += `ğŸ“Œ æ¬¡é‡ç‚¹${index + 1}ï¼ˆ${item.category} - ${item.title}ï¼‰ï¼š\n`;
                mediumContext += `${contentText}\n\n`;
            });
            
            messages.push({
                role: 'system',
                content: mediumContext
            });
            console.log(`[å¸¸é©»çŸ¥è¯†-æ¬¡é‡ç‚¹] å·²æ³¨å…¥ ${mediumPriorityKB.length} æ¡æ¬¡é‡ç‚¹çŸ¥è¯†`);
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P4ã€ä¸­é—´ã€‘å‘é‡æ£€ç´¢ï¼šé™æ€çŸ¥è¯†åº“
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        const staticKnowledge = await this.retrieveFromStaticKB(inputForRetrieval, 3);
        
        if (staticKnowledge.length > 0) {
            let knowledgeContext = 'ã€ç›¸å…³çŸ¥è¯†åº“ã€‘ä»¥ä¸‹æ˜¯ä¸å½“å‰æƒ…å¢ƒç›¸å…³çš„é¢„è®¾çŸ¥è¯†ï¼š\n\n';
            
            staticKnowledge.forEach((item, index) => {
                // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
                let contentText = item.content;
                if (typeof item.content === 'object' && item.content !== null) {
                    contentText = JSON.stringify(item.content, null, 2);
                }
                knowledgeContext += `çŸ¥è¯†${index + 1}ï¼ˆ${item.category} - ${item.title}ï¼Œç›¸ä¼¼åº¦${(item.similarity * 100).toFixed(1)}%ï¼‰ï¼š\n`;
                knowledgeContext += `${contentText}\n\n`;
            });
            
            messages.push({
                role: 'system',
                content: knowledgeContext
            });
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P5ã€è¾ƒä½ä¼˜å…ˆçº§ã€‘å¸¸é©»çŸ¥è¯†åº“ã€éé‡ç‚¹ã€‘- ä½ä¼˜å…ˆçº§å‚è€ƒ
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        if (lowPriorityKB.length > 0) {
            let lowContext = 'ã€å¸¸é©»çŸ¥è¯†åº“ã€‘ä»¥ä¸‹çŸ¥è¯†å§‹ç»ˆæœ‰æ•ˆï¼ˆå‚è€ƒä¿¡æ¯ï¼‰ï¼š\n\n';
            
            lowPriorityKB.forEach((item, index) => {
                // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
                let contentText = item.content;
                if (typeof item.content === 'object' && item.content !== null) {
                    contentText = JSON.stringify(item.content, null, 2);
                }
                lowContext += `çŸ¥è¯†${index + 1}ï¼ˆ${item.category} - ${item.title}ï¼‰ï¼š\n`;
                lowContext += `${contentText}\n\n`;
            });
            
            messages.push({
                role: 'system',
                content: lowContext
            });
            
            console.log(`[å¸¸é©»çŸ¥è¯†-éé‡ç‚¹] å·²æ³¨å…¥ ${lowPriorityKB.length} æ¡éé‡ç‚¹çŸ¥è¯†`);
        }
        
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        // P6ã€å½“å‰è¾“å…¥ã€‘æœ«å°¾å¼ºåŒ– - åªå‘é€æœ€æ–°çš„ç”¨æˆ·è¾“å…¥
        // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        messages.push({
            role: 'user',
            content: currentInput
        });
        
        const totalHistory = conversationHistory.length;
        const totalTurns = Math.floor(totalHistory / 2);
        const vectorCount = retrievalResult.relevantChunks.length;
        const kbCount = staticKnowledge.length;
        const aiReplyCount = filteredHistory.length;
        const highKBCount = highPriorityKB.length;
        const mediumKBCount = mediumPriorityKB.length;
        const lowKBCount = lowPriorityKB.length;
        const totalAlwaysKB = alwaysIncludeKnowledge.length;
        
        console.log(`â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—`);
        console.log(`â•‘  ğŸ§¬ ä¼˜åŒ–ä¸Šä¸‹æ–‡æ„å»ºæŠ¥å‘Šï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰         â•‘`);
        console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
        console.log(`â•‘  ğŸ“Š åŸå§‹æ•°æ®ï¼š                                  â•‘`);
        console.log(`â•‘    - æ€»å¯¹è¯è½®æ•°ï¼š${totalTurns}è½®ï¼ˆ${totalHistory}æ¡æ¶ˆæ¯ï¼‰          â•‘`);
        console.log(`â•‘    - å†å²å±‚æ•°è®¾ç½®ï¼š${historyDepth}å±‚                        â•‘`);
        console.log(`â•‘    - å‘é‡åº“å¤§å°ï¼š${this.conversationEmbeddings.length}è½®                          â•‘`);
        console.log(`â•‘    - Historyå‘é‡åº“ï¼š${this.historyEmbeddings.length}æ¡                       â•‘`);
        
        // ğŸ†• æ·»åŠ çŸ©é˜µä¿¡æ¯
        let matrixLayersCount = 0;
        if (window.matrixManager && window.matrixManager.historyMatrix) {
            matrixLayersCount = window.matrixManager.historyMatrix.layers.length;
        }
        console.log(`â•‘    - HistoryçŸ©é˜µå±‚æ•°ï¼š${matrixLayersCount}å±‚                        â•‘`);
        console.log(`â•‘    - é™æ€çŸ¥è¯†åº“ï¼š${this.staticKnowledgeBase.length}æ¡                          â•‘`);
        
        // ğŸ†• æ·»åŠ äººç‰©å›¾è°±ä¿¡æ¯
        let characterGraphCount = 0;
        let characterGraphMatched = 0;
        let characterGraphSent = 0;
        if (window.characterGraphManager) {
            characterGraphCount = window.characterGraphManager.characters.size;
            characterGraphMatched = window.characterGraphManager.stats.matchCount || 0;
        }
        // ç»Ÿè®¡æœ¬æ¬¡å‘é€ç»™AIçš„äººç‰©æ•°é‡
        if (currentVariables && currentVariables.relationships) {
            characterGraphSent = currentVariables.relationships.length;
        }
        console.log(`â•‘    - äººç‰©å›¾è°±ï¼š${characterGraphCount}äººï¼ˆå·²åŒ¹é…${characterGraphMatched}æ¬¡ï¼‰           â•‘`);
        
        console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
        console.log(`â•‘  ğŸ“¤ å®é™…å‘é€ï¼ˆä¼˜å…ˆçº§ä»é«˜åˆ°ä½ï¼‰ï¼š                â•‘`);
        console.log(`â•‘    P0   ç³»ç»Ÿæç¤ºè¯ï¼š1æ¡ï¼ˆJSONæ ¼å¼è§„åˆ™ï¼‰         â•‘`);
        console.log(`â•‘    P1   å˜é‡çŠ¶æ€ï¼š1æ¡ï¼ˆå½“å‰å±æ€§æ•°æ®ï¼‰           â•‘`);
        console.log(`â•‘    P1.1 äººç‰©å›¾è°±ï¼š${characterGraphSent}äººï¼ˆåŒ¹é…ç›¸å…³ï¼‰ ğŸ‘¤         â•‘`);
        console.log(`â•‘    P1.5 Historyä¸“ç”¨ï¼š${matrixRecentCount}æ¡æœ€è¿‘ + ${matrixRetrievedCount}æ¡çŸ©é˜µæ£€ç´¢ ğŸ“š  â•‘`);
        console.log(`â•‘    P2   æœ€è¿‘AIå›å¤ï¼š${aiReplyCount}æ¡ï¼ˆå‰§æƒ…è¿è´¯ï¼‰           â•‘`);
        console.log(`â•‘    P2.5 å¸¸é©»ã€é‡ç‚¹ã€‘ï¼š${highKBCount}æ¡ â­                   â•‘`);
        console.log(`â•‘    P3   å‘é‡æ£€ç´¢å†å²ï¼š${vectorCount}æ¡ï¼ˆè¿œæœŸè®°å¿†ï¼‰          â•‘`);
        console.log(`â•‘    P3.5 å¸¸é©»ã€æ¬¡é‡ç‚¹ã€‘ï¼š${mediumKBCount}æ¡ ğŸ“Œ               â•‘`);
        console.log(`â•‘    P4   å‘é‡æ£€ç´¢çŸ¥è¯†åº“ï¼š${kbCount}æ¡ï¼ˆç›¸å…³çŸ¥è¯†ï¼‰          â•‘`);
        console.log(`â•‘    P5   å¸¸é©»ã€éé‡ç‚¹ã€‘ï¼š${lowKBCount}æ¡                   â•‘`);
        console.log(`â•‘    P6   å½“å‰è¾“å…¥ï¼š1æ¡ï¼ˆæœ«å°¾å¼ºåŒ–ï¼‰               â•‘`);
        console.log(`â•‘  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â•‘`);
        console.log(`â•‘    å¸¸é©»çŸ¥è¯†æ€»è®¡ï¼š${totalAlwaysKB}æ¡ï¼ˆåˆ†3çº§æ³¨å…¥ï¼‰            â•‘`);
        console.log(`â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£`);
        console.log(`â•‘  ğŸ’¡ æ€»æ¶ˆæ¯æ•°ï¼š${messages.length}æ¡                                  â•‘`);
        console.log(`â•‘  ğŸ’° TokenèŠ‚çœï¼šçº¦${totalHistory > 0 ? Math.round((1 - aiReplyCount/totalHistory) * 100) : 0}%ï¼ˆè¿‡æ»¤å†å²ç”¨æˆ·è¾“å…¥ï¼‰  â•‘`);
        console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
        
        return messages;
    }

    /**
     * ã€æ–¹æ¡ˆ2ã€‘é€šè¿‡APIè·å–embeddingï¼ˆéœ€è¦é…ç½®é¢å¤–APIï¼‰
     */
    async getEmbeddingFromAPI(text) {
        // ğŸ”§ ä¿®å¤ï¼šç¡®ä¿textæ˜¯å­—ç¬¦ä¸²ç±»å‹
        if (typeof text !== 'string') {
            if (text === null || text === undefined) {
                console.warn('[å‘é‡API] textä¸ºç©ºï¼Œå›é€€åˆ°å…³é”®è¯æ–¹æ³•');
                return this.createKeywordVector('');
            }
            // å¦‚æœæ˜¯å¯¹è±¡ï¼Œè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
            if (typeof text === 'object') {
                text = JSON.stringify(text);
            } else {
                // å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                text = String(text);
            }
        }

        // æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†é¢å¤–API
        if (!window.extraApiConfig || !window.extraApiConfig.enabled) {
            console.warn('[å‘é‡API] é¢å¤–APIæœªå¯ç”¨ï¼Œå›é€€åˆ°å…³é”®è¯æ–¹æ³•');
            return this.createKeywordVector(text);
        }
        
        try {
            const endpoint = window.extraApiConfig.endpoint.trim().replace(/\/+$/, '');
            const apiKey = window.extraApiConfig.key;
            
            // OpenAI embeddings API
            const response = await fetch(`${endpoint}/embeddings`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    input: text.substring(0, 8000), // é™åˆ¶é•¿åº¦
                    model: 'text-embedding-ada-002' // å¯é…ç½®
                })
            });
            
            if (!response.ok) {
                throw new Error(`APIé”™è¯¯: ${response.status}`);
            }
            
            const data = await response.json();
            return data.data[0].embedding; // è¿”å›å‘é‡æ•°ç»„
            
        } catch (error) {
            console.error('[å‘é‡API] è°ƒç”¨å¤±è´¥:', error);
            // å›é€€åˆ°å…³é”®è¯æ–¹æ³•
            return this.createKeywordVector(text);
        }
    }

    /**
     * ã€æ–¹æ¡ˆ3ã€‘ä½¿ç”¨transformers.jsï¼ˆæµè§ˆå™¨ç«¯æ¨¡å‹ï¼‰
     * éœ€è¦å…ˆåŠ è½½ï¼šwindow.loadTransformersJS()
     */
    async getEmbeddingFromTransformers(text) {
        // ğŸ”§ ä¿®å¤ï¼šç¡®ä¿textæ˜¯å­—ç¬¦ä¸²ç±»å‹
        if (typeof text !== 'string') {
            if (text === null || text === undefined) {
                console.warn('[Transformers.js] textä¸ºç©ºï¼Œå›é€€åˆ°å…³é”®è¯æ–¹æ³•');
                return this.createKeywordVector('');
            }
            // å¦‚æœæ˜¯å¯¹è±¡ï¼Œè½¬æ¢ä¸ºJSONå­—ç¬¦ä¸²
            if (typeof text === 'object') {
                text = JSON.stringify(text);
            } else {
                // å…¶ä»–ç±»å‹è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                text = String(text);
            }
        }

        try {
            // æ£€æŸ¥åº“æ˜¯å¦åŠ è½½
            if (typeof window.transformers === 'undefined' && typeof window.loadTransformersJS === 'function') {
                if (window.DEBUG_TRANSFORMERS) console.log('[Transformers.js] æ­£åœ¨åŠ è½½åº“ï¼ˆé¦–æ¬¡åŠ è½½ï¼‰...');
                await window.loadTransformersJS();
            }
            
            if (typeof window.transformers === 'undefined') {
                console.warn('[Transformers.js] åº“åŠ è½½å¤±è´¥ï¼Œå›é€€åˆ°å…³é”®è¯æ–¹æ³•');
                return this.createKeywordVector(text);
            }
            
            // ğŸ”§ ç¡®ä¿è®¾ç½®æ­£ç¡®çš„ç¯å¢ƒå˜é‡ï¼ˆæ¯æ¬¡éƒ½æ£€æŸ¥ï¼‰
            if (window.transformers.env) {
                window.transformers.env.localModelPath = './';
                window.transformers.env.allowRemoteModels = true;
                if (window.DEBUG_TRANSFORMERS) console.log('[Transformers.js] ç¯å¢ƒé…ç½®å·²æ›´æ–°:', window.transformers.env.localModelPath);
            }
            
            // ä½¿ç”¨è½»é‡çº§å¤šè¯­è¨€æ¨¡å‹
            const { pipeline } = window.transformers;
            
            if (!this.embeddingPipeline) {
                // ğŸ¯ ç›´æ¥ä½¿ç”¨CDNæ¨¡å‹ï¼ˆæœ¬åœ°æ¨¡å‹åœ¨file://åè®®ä¸‹æ— æ³•åŠ è½½ï¼‰
                const modelSource = this.modelConfig.cdnModelName;  // âœ… å¼ºåˆ¶ä½¿ç”¨CDN
                
                const modelSize = this.modelConfig.useQuantized ? '13MB' : '50MB';
                const sourceText = 'ä»HuggingFace CDN';  // âœ… æ˜ç¡®æ ‡æ³¨æ¥æº
                const silentLoad = (typeof window !== 'undefined' && window.localStorage && localStorage.getItem('transformers_model_ready') === '1') && !window.DEBUG_TRANSFORMERS;
                console.log(`[Transformers.js] æ­£åœ¨åˆå§‹åŒ–æ¨¡å‹ï¼ˆå¤§å°çº¦${modelSize}ï¼Œé¦–æ¬¡éœ€ä¸‹è½½ï¼‰...`);
                console.log(`[Transformers.js] æ¨¡å‹æ¥æº: ${modelSource}`);
                
                // æ˜¾ç¤ºåŠ è½½æç¤ºï¼ˆä»…é¦–æ¬¡æˆ–è°ƒè¯•æ—¶ï¼‰
                if (!silentLoad && typeof window !== 'undefined' && window.document) {
                    const loadingMsg = document.createElement('div');
                    loadingMsg.id = 'transformersLoading';
                    loadingMsg.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: white;
                        padding: 30px;
                        border-radius: 15px;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                        z-index: 10001;
                        text-align: center;
                        min-width: 320px;
                        max-width: 90vw;
                    `;
                    loadingMsg.innerHTML = `
                        <div style="color: #667eea; font-size: 20px; font-weight: bold; margin-bottom: 15px;">
                            ğŸ¤– æ­£åœ¨åŠ è½½AIæ¨¡å‹...
                        </div>
                        <div style="color: #666; font-size: 14px; margin-bottom: 15px;">
                            ${sourceText}ä¸‹è½½çº¦ ${modelSize}ï¼Œè¯·ç¨å€™...
                        </div>
                        
                        <!-- è¿›åº¦ä¿¡æ¯å®¹å™¨ -->
                        <div id="progressInfo" style="margin: 15px 0; color: #333; font-size: 13px;">
                            <div id="progressStatus" style="margin-bottom: 8px; font-weight: bold;">
                                ğŸ“¥ æ­£åœ¨è¿æ¥æœåŠ¡å™¨...
                            </div>
                            <div id="progressBar" style="
                                width: 100%;
                                height: 24px;
                                background: #f0f0f0;
                                border-radius: 12px;
                                overflow: hidden;
                                margin-bottom: 10px;
                                position: relative;
                            ">
                                <div id="progressBarFill" style="
                                    width: 0%;
                                    height: 100%;
                                    background: linear-gradient(90deg, #667eea, #764ba2);
                                    transition: width 0.3s ease;
                                    display: flex;
                                    align-items: center;
                                    justify-content: center;
                                ">
                                    <span id="progressPercent" style="
                                        color: white;
                                        font-size: 11px;
                                        font-weight: bold;
                                        position: absolute;
                                        left: 50%;
                                        transform: translateX(-50%);
                                    ">0%</span>
                                </div>
                            </div>
                            <div id="progressDetails" style="font-size: 12px; color: #666; line-height: 1.6;">
                                <div id="downloadSpeed">é€Ÿåº¦: è®¡ç®—ä¸­...</div>
                                <div id="downloadedSize">å·²ä¸‹è½½: 0 KB</div>
                                <div id="remainingTime">é¢„è®¡å‰©ä½™: è®¡ç®—ä¸­...</div>
                            </div>
                        </div>
                        
                        <div class="loading" style="margin: 20px auto;"></div>
                        <div style="color: #999; font-size: 12px; margin-top: 15px;">
                            ${this.modelConfig.useLocalModel ? 'ğŸ’¡ æ¨¡å‹æ‰˜ç®¡åœ¨æœ¬ç«™ï¼Œä¸‹è½½æ›´å¿«' : 'ğŸ“¡ ä»å¤–éƒ¨CDNä¸‹è½½'}
                        </div>
                        <div style="color: #999; font-size: 11px; margin-top: 8px;">
                            ğŸ’¡ æç¤ºï¼šæ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°å¯æŸ¥çœ‹è¯¦ç»†æ—¥å¿—
                        </div>
                    `;
                    document.body.appendChild(loadingMsg);
                    
                    // ğŸ†• æ·»åŠ è¿›åº¦è¿½è¸ªå˜é‡
                    window._modelLoadProgress = {
                        startTime: Date.now(),
                        loaded: 0,
                        total: 0,
                        lastUpdate: Date.now(),
                        lastLoaded: 0,
                        files: new Map() // è¿½è¸ªæ¯ä¸ªæ–‡ä»¶çš„ä¸‹è½½è¿›åº¦
                    };
                    
                    // ğŸ†• å®šä¹‰UIæ›´æ–°å‡½æ•°
                    window._updateProgressUI = function() {
                        const progress = window._modelLoadProgress;
                        if (!progress) return;
                        
                        const now = Date.now();
                        const timeDiff = (now - progress.lastUpdate) / 1000; // ç§’
                        
                        // è‡³å°‘é—´éš”0.1ç§’æ›´æ–°ä¸€æ¬¡UIï¼Œé¿å…é¢‘ç¹é‡ç»˜
                        if (timeDiff < 0.1) return;
                        
                        // è®¡ç®—ä¸‹è½½é€Ÿåº¦ (bytes/sec)
                        const loadedDiff = progress.loaded - progress.lastLoaded;
                        const speed = timeDiff > 0 ? loadedDiff / timeDiff : 0;
                        
                        // è®¡ç®—ç™¾åˆ†æ¯”
                        const percent = progress.total > 0 
                            ? Math.min(100, (progress.loaded / progress.total * 100))
                            : 0;
                        
                        // è®¡ç®—å‰©ä½™æ—¶é—´
                        const remaining = progress.total - progress.loaded;
                        const remainingTime = speed > 0 ? remaining / speed : 0;
                        
                        // æ ¼å¼åŒ–å‡½æ•°
                        const formatSize = (bytes) => {
                            if (bytes < 1024) return bytes.toFixed(0) + ' B';
                            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                            return (bytes / 1024 / 1024).toFixed(2) + ' MB';
                        };
                        
                        const formatTime = (seconds) => {
                            if (seconds < 60) return seconds.toFixed(0) + 'ç§’';
                            return Math.floor(seconds / 60) + 'åˆ†' + (seconds % 60).toFixed(0) + 'ç§’';
                        };
                        
                        const formatSpeed = (bytesPerSec) => {
                            if (bytesPerSec < 1024) return bytesPerSec.toFixed(0) + ' B/s';
                            if (bytesPerSec < 1024 * 1024) return (bytesPerSec / 1024).toFixed(1) + ' KB/s';
                            return (bytesPerSec / 1024 / 1024).toFixed(2) + ' MB/s';
                        };
                        
                        // æ›´æ–°UIå…ƒç´ 
                        const statusEl = document.getElementById('progressStatus');
                        const barEl = document.getElementById('progressBarFill');
                        const percentEl = document.getElementById('progressPercent');
                        const speedEl = document.getElementById('downloadSpeed');
                        const sizeEl = document.getElementById('downloadedSize');
                        const timeEl = document.getElementById('remainingTime');
                        
                        if (statusEl) {
                            if (percent > 0) {
                                statusEl.textContent = 'ğŸ“¥ æ­£åœ¨ä¸‹è½½æ¨¡å‹æ–‡ä»¶...';
                            }
                        }
                        
                        if (barEl) {
                            barEl.style.width = percent.toFixed(1) + '%';
                        }
                        
                        if (percentEl) {
                            percentEl.textContent = percent.toFixed(1) + '%';
                            // å½“è¿›åº¦æ¡å¾ˆçª„æ—¶ï¼Œè°ƒæ•´æ–‡å­—é¢œè‰²
                            percentEl.style.color = percent < 10 ? '#333' : 'white';
                        }
                        
                        if (speedEl) {
                            speedEl.textContent = 'é€Ÿåº¦: ' + formatSpeed(speed);
                        }
                        
                        if (sizeEl) {
                            const totalText = progress.total > 0 ? ' / ' + formatSize(progress.total) : '';
                            sizeEl.textContent = 'å·²ä¸‹è½½: ' + formatSize(progress.loaded) + totalText;
                        }
                        
                        if (timeEl) {
                            if (remainingTime > 0 && remainingTime < 3600) {
                                timeEl.textContent = 'é¢„è®¡å‰©ä½™: ' + formatTime(remainingTime);
                            } else {
                                timeEl.textContent = 'é¢„è®¡å‰©ä½™: è®¡ç®—ä¸­...';
                            }
                        }
                        
                        // æ›´æ–°è¿½è¸ªæ•°æ®
                        progress.lastUpdate = now;
                        progress.lastLoaded = progress.loaded;
                        
                        // è¾“å‡ºæ—¥å¿—ï¼ˆå¯é€‰ï¼‰
                        if (window.DEBUG_TRANSFORMERS && percent > 0) {
                            console.log(`[æ¨¡å‹ä¸‹è½½] è¿›åº¦: ${percent.toFixed(1)}% | é€Ÿåº¦: ${formatSpeed(speed)} | å·²ä¸‹è½½: ${formatSize(progress.loaded)}`);
                        }
                    };
                    
                    // å¯åŠ¨å®šæ—¶å™¨ï¼Œæ¯500msæ›´æ–°ä¸€æ¬¡UIï¼ˆå³ä½¿æ²¡æœ‰æ–°æ•°æ®ä¹Ÿæ˜¾ç¤ºçŠ¶æ€ï¼‰
                    const progressTimer = setInterval(() => {
                        if (window._updateProgressUI) {
                            window._updateProgressUI();
                        }
                        // å¦‚æœåŠ è½½å®Œæˆï¼Œæ¸…é™¤å®šæ—¶å™¨
                        if (!document.getElementById('transformersLoading')) {
                            clearInterval(progressTimer);
                        }
                    }, 500);
                }
                
                // ğŸ”§ åœ¨åŠ è½½å¼€å§‹å‰å…ˆæ¿€æ´»è¿›åº¦è¿½è¸ª
                if (typeof window._setupProgressTracking === 'function') {
                    window._setupProgressTracking();
                    console.log('[Transformers.js] è¿›åº¦è¿½è¸ªå·²å¯åŠ¨');
                }
                
                try {
                    // ğŸš€ åŠ è½½æ¨¡å‹
                    console.log(`[Transformers.js] å¼€å§‹åŠ è½½æ¨¡å‹: ${modelSource}`);
                    this.embeddingPipeline = await pipeline(
                        'feature-extraction', 
                        modelSource,
                        {
                            quantized: this.modelConfig.useQuantized  // åŠ¨æ€æ§åˆ¶æ˜¯å¦ä½¿ç”¨é‡åŒ–æ¨¡å‹
                        }
                    );
                    
                    // ç§»é™¤åŠ è½½æç¤º
                    const loadingMsg = document.getElementById('transformersLoading');
                    if (loadingMsg) loadingMsg.remove();
                    
                    if (typeof window !== 'undefined' && window.localStorage) { try { localStorage.setItem('transformers_model_ready','1'); } catch (e) {} }
                    console.log('[Transformers.js] âœ… æ¨¡å‹åŠ è½½å®Œæˆï¼æ¥æº: HuggingFace CDN');
                    
                } catch (error) {
                    // ç§»é™¤åŠ è½½æç¤º
                    const loadingMsg = document.getElementById('transformersLoading');
                    if (loadingMsg) loadingMsg.remove();
                    
                    // âŒ CDNåŠ è½½å¤±è´¥ï¼Œç›´æ¥æŠ›å‡ºé”™è¯¯
                    console.error('[Transformers.js] âŒ æ¨¡å‹åŠ è½½å¤±è´¥:', error);
                    console.error('[Transformers.js] æ¨¡å‹æ¥æº:', modelSource);
                    
                    // è¯¦ç»†é”™è¯¯ä¿¡æ¯
                    let errorDetails = error.message;
                    if (error.message.includes('Failed to fetch')) {
                        errorDetails = 'ç½‘ç»œé”™è¯¯ï¼šæ— æ³•è¿æ¥åˆ° HuggingFace CDN\n\nå¯èƒ½åŸå› ï¼š\n1. ç½‘ç»œè¿æ¥é—®é¢˜\n2. HuggingFace è¢«å¢™ï¼ˆéœ€è¦ä»£ç†ï¼‰\n3. æœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨\n\nå»ºè®®ï¼š\n- æ£€æŸ¥ç½‘ç»œè¿æ¥\n- å°è¯•ä½¿ç”¨ä»£ç†/VPN\n- ç¨åé‡è¯•';
                    }
                    
                    throw new Error(`æ¨¡å‹åŠ è½½å¤±è´¥ï¼š\n${errorDetails}`);
                }
            }
            
            // ç”Ÿæˆå‘é‡
            const output = await this.embeddingPipeline(text.substring(0, 500), {
                pooling: 'mean',
                normalize: true
            });
            
            // è½¬æ¢ä¸ºæ™®é€šæ•°ç»„
            const vector = Array.from(output.data);
            
            console.log(`[Transformers.js] å‘é‡ç”ŸæˆæˆåŠŸï¼ˆç»´åº¦ï¼š${vector.length}ï¼‰`);
            
            return vector;
            
        } catch (error) {
            console.error('[Transformers.js] é”™è¯¯:', error);
            
            // ç§»é™¤åŠ è½½æç¤ºï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const loadingMsg = document.getElementById('transformersLoading');
            if (loadingMsg) loadingMsg.remove();
            
            // å›é€€åˆ°å…³é”®è¯æ–¹æ³•
            console.warn('[Transformers.js] å›é€€åˆ°å…³é”®è¯æ–¹æ³•');
            return this.createKeywordVector(text);
        }
    }

    /**
     * åˆ‡æ¢embeddingæ–¹æ³•
     */
    setEmbeddingMethod(method) {
        if (['keyword', 'api', 'transformers'].includes(method)) {
            this.embeddingMethod = method;
            console.log(`[å‘é‡æ–¹æ³•] å·²åˆ‡æ¢åˆ°: ${method}`);
        } else {
            console.error('[å‘é‡æ–¹æ³•] æ— æ•ˆçš„æ–¹æ³•:', method);
        }
    }

    /**
     * ğŸ†• ä»å¢å¼ºçš„ç”¨æˆ·è¾“å…¥ä¸­æå–æ ¸å¿ƒæŸ¥è¯¢
     * å»é™¤ç³»ç»Ÿæç¤ºï¼Œåªä¿ç•™ç”¨æˆ·åŸå§‹è¾“å…¥
     */
    extractCoreQuery(enhancedInput) {
        if (!enhancedInput) return '';
        
        // å»é™¤ç³»ç»Ÿæç¤ºï¼ˆä»¥ [ç³»ç»Ÿæç¤ºã€[é‡è¦æé†’ ç­‰å¼€å¤´çš„å†…å®¹ï¼‰
        const lines = enhancedInput.split('\n');
        const coreLines = [];
        
        for (const line of lines) {
            const trimmed = line.trim();
            // è·³è¿‡ç³»ç»Ÿæç¤ºè¡Œ
            if (trimmed.startsWith('[ç³»ç»Ÿæç¤º') || 
                trimmed.startsWith('[é‡è¦æé†’') || 
                trimmed.startsWith('[æå…¶é‡è¦') ||
                trimmed.startsWith('[äººé™…å…³ç³»') ||
                trimmed.startsWith('[æ•°ç»„å®Œæ•´') ||
                trimmed.startsWith('[ğŸ”´') ||
                trimmed.startsWith('[å±æ€§åˆ¤å®š') ||
                trimmed === '') {
                continue;
            }
            coreLines.push(line);
        }
        
        const coreQuery = coreLines.join('\n').trim();
        console.log(`[æå–æ ¸å¿ƒæŸ¥è¯¢] åŸå§‹é•¿åº¦: ${enhancedInput.length}, æå–åé•¿åº¦: ${coreQuery.length}`);
        
        return coreQuery || enhancedInput; // å¦‚æœæå–å¤±è´¥ï¼Œè¿”å›åŸå§‹è¾“å…¥
    }

    /**
     * æ¸…ç©ºå‘é‡åº“
     */
    clear() {
        this.conversationEmbeddings = [];
        this.historyEmbeddings = [];  // ğŸ”§ ä¿®å¤ï¼šåŒæ—¶æ¸…ç©ºhistoryå‘é‡åº“
        console.log('[å‘é‡åº“] å·²æ¸…ç©ºï¼ˆåŒ…æ‹¬historyå‘é‡åº“ï¼‰');
    }

    /**
     * ğŸ†• ä»JSONæ–‡ä»¶åŠ è½½é™æ€çŸ¥è¯†åº“ï¼ˆå¯¼å…¥åä¿å­˜åˆ°IndexedDBï¼‰
     * @param {string} filePath - çŸ¥è¯†åº“æ–‡ä»¶è·¯å¾„
     * @param {boolean} append - æ˜¯å¦è¿½åŠ ï¼ˆé»˜è®¤æ›¿æ¢ï¼‰
     */
    async loadStaticKnowledgeFromFile(filePath, append = false) {
        try {
            console.log(`[é™æ€çŸ¥è¯†åº“] æ­£åœ¨åŠ è½½æ–‡ä»¶: ${filePath}`);
            
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`æ— æ³•åŠ è½½æ–‡ä»¶: ${filePath} (HTTP ${response.status})`);
            }
            
            const data = await response.json();
            
            // å¯¼å…¥å¹¶ä¿å­˜åˆ°IndexedDBï¼ˆä½¿ç”¨é»˜è®¤çš„saveToIndexedDB=trueï¼‰
            return await this.importStaticKnowledge(data, !append);
            
        } catch (error) {
            console.error('[é™æ€çŸ¥è¯†åº“] åŠ è½½å¤±è´¥:', error);
            throw error;
        }
    }
    
    /**
     * ğŸ†• æ‰¹é‡åŠ è½½å¤šä¸ªçŸ¥è¯†åº“æ–‡ä»¶
     * @param {Array<string>} filePaths - æ–‡ä»¶è·¯å¾„æ•°ç»„
     */
    async loadMultipleKnowledgeFiles(filePaths) {
        console.log(`[é™æ€çŸ¥è¯†åº“] æ‰¹é‡åŠ è½½ ${filePaths.length} ä¸ªæ–‡ä»¶...`);
        
        let totalLoaded = 0;
        const errors = [];
        
        for (let i = 0; i < filePaths.length; i++) {
            const filePath = filePaths[i];
            try {
                const result = await this.loadStaticKnowledgeFromFile(filePath, true); // è¿½åŠ æ¨¡å¼
                totalLoaded += result.count;
                console.log(`[é™æ€çŸ¥è¯†åº“] âœ… [${i+1}/${filePaths.length}] ${filePath} - åŠ è½½äº† ${result.count} æ¡`);
            } catch (error) {
                console.error(`[é™æ€çŸ¥è¯†åº“] âŒ [${i+1}/${filePaths.length}] ${filePath} - å¤±è´¥: ${error.message}`);
                errors.push({ file: filePath, error: error.message });
            }
        }
        
        console.log(`[é™æ€çŸ¥è¯†åº“] æ‰¹é‡åŠ è½½å®Œæˆï¼šæˆåŠŸ ${totalLoaded} æ¡ï¼Œå¤±è´¥ ${errors.length} ä¸ªæ–‡ä»¶`);
        
        return {
            totalLoaded: totalLoaded,
            totalFiles: filePaths.length,
            errors: errors
        };
    }
    
    /**
     * ğŸ†• ä¿å­˜çŸ¥è¯†åº“æ–‡ä»¶è·¯å¾„é…ç½®
     */
    saveKBFileConfig(filePaths) {
        this.staticKBFiles = filePaths;
        // ä¿å­˜åˆ°localStorage
        localStorage.setItem('staticKBFiles', JSON.stringify(filePaths));
        console.log(`[é™æ€çŸ¥è¯†åº“] å·²ä¿å­˜ ${filePaths.length} ä¸ªæ–‡ä»¶è·¯å¾„é…ç½®`);
    }
    
    /**
     * ğŸ†• åŠ è½½çŸ¥è¯†åº“æ–‡ä»¶è·¯å¾„é…ç½®
     */
    loadKBFileConfig() {
        try {
            const saved = localStorage.getItem('staticKBFiles');
            if (saved) {
                this.staticKBFiles = JSON.parse(saved);
                console.log(`[é™æ€çŸ¥è¯†åº“] å·²åŠ è½½ ${this.staticKBFiles.length} ä¸ªæ–‡ä»¶è·¯å¾„é…ç½®`);
                return this.staticKBFiles;
            }
        } catch (error) {
            console.error('[é™æ€çŸ¥è¯†åº“] åŠ è½½æ–‡ä»¶è·¯å¾„é…ç½®å¤±è´¥:', error);
        }
        return [];
    }
    
    /**
     * ğŸ†• è‡ªåŠ¨åŠ è½½é…ç½®çš„çŸ¥è¯†åº“æ–‡ä»¶
     */
    async autoLoadStaticKB() {
        const filePaths = this.loadKBFileConfig();
        
        if (filePaths.length === 0) {
            console.log('[é™æ€çŸ¥è¯†åº“] æ²¡æœ‰é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œè·³è¿‡è‡ªåŠ¨åŠ è½½');
            return;
        }
        
        if (!this.autoLoadStaticKB) {
            console.log('[é™æ€çŸ¥è¯†åº“] è‡ªåŠ¨åŠ è½½å·²ç¦ç”¨');
            return;
        }
        
        console.log(`[é™æ€çŸ¥è¯†åº“] è‡ªåŠ¨åŠ è½½å¼€å§‹...`);
        
        try {
            const result = await this.loadMultipleKnowledgeFiles(filePaths);
            console.log(`[é™æ€çŸ¥è¯†åº“] âœ… è‡ªåŠ¨åŠ è½½å®Œæˆï¼å…± ${result.totalLoaded} æ¡çŸ¥è¯†`);
            
            return result;
        } catch (error) {
            console.error('[é™æ€çŸ¥è¯†åº“] è‡ªåŠ¨åŠ è½½å¤±è´¥:', error);
            return null;
        }
    }

    /**
     * ğŸ†• å¯¼å…¥é™æ€çŸ¥è¯†åº“æ•°æ®
     * @param {Object} data - çŸ¥è¯†åº“æ•°æ®
     * @param {boolean} replace - æ˜¯å¦æ›¿æ¢ç°æœ‰çŸ¥è¯†åº“ï¼ˆé»˜è®¤è¿½åŠ ï¼‰
     * @param {boolean} saveToIndexedDB - æ˜¯å¦ä¿å­˜åˆ°IndexedDBï¼ˆé»˜è®¤trueï¼ŒæŒä¹…åŒ–å­˜å‚¨ï¼‰
     */
    async importStaticKnowledge(data, replace = false, saveToIndexedDB = true) {
        try {
            if (replace) {
                this.staticKnowledgeBase = [];
            }
            
            let importCount = 0;
            
            // æ”¯æŒä¸¤ç§æ ¼å¼ï¼š
            // 1. ç›´æ¥æ˜¯å‘é‡æ•°ç»„
            // 2. åŒ…å« knowledge å­—æ®µçš„å¯¹è±¡
            const knowledgeItems = Array.isArray(data) ? data : (data.knowledge || data.items || []);
            
            // ğŸ”§ æ–°å¢ï¼šä¸å‘é‡åŒ–æ¨¡å¼ï¼ˆå¯¹äºå¤§å‹çŸ¥è¯†åº“ï¼Œæ£€ç´¢æ—¶å®æ—¶ç”Ÿæˆå‘é‡ï¼‰
            const skipVectorization = knowledgeItems.length > 100; // è¶…è¿‡100æ¡ï¼Œè·³è¿‡é¢„å‘é‡åŒ–
            
            if (skipVectorization) {
                console.log(`[é™æ€çŸ¥è¯†åº“] âš¡ å¤§å‹çŸ¥è¯†åº“ï¼ˆ${knowledgeItems.length}æ¡ï¼‰ï¼Œå¯ç”¨å®æ—¶å‘é‡åŒ–æ¨¡å¼`);
            }
            
            for (const item of knowledgeItems) {
                const itemId = item.id || `kb_${Date.now()}_${importCount}`;
                
                // ğŸ”§ æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒidçš„æ¡ç›®ï¼ˆç‰¹åˆ«æ˜¯system_prompt_mainï¼‰
                const existingIndex = this.staticKnowledgeBase.findIndex(existing => existing.id === itemId);
                
                let newItem;
                
                // å¦‚æœå·²ç»åŒ…å«å‘é‡ï¼Œç›´æ¥ä½¿ç”¨
                if (item.vector) {
                    newItem = {
                        id: itemId,
                        title: item.title || 'æœªå‘½åçŸ¥è¯†',
                        content: item.content || '',
                        category: item.category || 'é€šç”¨',
                        tags: item.tags || [],
                        alwaysInclude: item.alwaysInclude || false, // ğŸ†• ä¿ç•™å¸¸é©»è®¾ç½®
                        priority: item.priority, // ğŸ†• ä¿ç•™ä¼˜å…ˆçº§ï¼ˆhigh/medium/lowï¼‰
                        vector: item.vector,
                        vectorType: Array.isArray(item.vector) ? 'dense' : 'sparse',
                        metadata: item.metadata || {}
                    };
                } 
                // å¦‚æœæ²¡æœ‰å‘é‡
                else if (item.content) {
                    if (skipVectorization) {
                        // å¤§å‹çŸ¥è¯†åº“ï¼šä¸é¢„å…ˆç”Ÿæˆå‘é‡ï¼Œåªå­˜contentï¼Œæ£€ç´¢æ—¶å®æ—¶ç”Ÿæˆ
                        newItem = {
                            id: itemId,
                            title: item.title || 'æœªå‘½åçŸ¥è¯†',
                            content: item.content,
                            category: item.category || 'é€šç”¨',
                            tags: item.tags || [],
                            alwaysInclude: item.alwaysInclude || false, // ğŸ†• ä¿ç•™å¸¸é©»è®¾ç½®
                            priority: item.priority, // ğŸ†• ä¿ç•™ä¼˜å…ˆçº§
                            vector: null, // ä¸é¢„å…ˆç”Ÿæˆ
                            vectorType: 'lazy', // æ ‡è®°ä¸ºå»¶è¿Ÿç”Ÿæˆ
                            metadata: item.metadata || {}
                        };
                    } else {
                        // å°å‹çŸ¥è¯†åº“ï¼šé¢„å…ˆç”Ÿæˆå‘é‡
                        const vector = await this.generateVector(item.content);
                        
                        newItem = {
                            id: itemId,
                            title: item.title || 'æœªå‘½åçŸ¥è¯†',
                            content: item.content,
                            category: item.category || 'é€šç”¨',
                            tags: item.tags || [],
                            alwaysInclude: item.alwaysInclude || false, // ğŸ†• ä¿ç•™å¸¸é©»è®¾ç½®
                            priority: item.priority, // ğŸ†• ä¿ç•™ä¼˜å…ˆçº§
                            vector: vector,
                            vectorType: Array.isArray(vector) ? 'dense' : 'sparse',
                            metadata: item.metadata || {}
                        };
                    }
                } else {
                    continue; // è·³è¿‡æ— æ•ˆæ¡ç›®
                }
                
                // ğŸ”§ å¦‚æœå·²å­˜åœ¨ï¼Œè¦†ç›–ï¼›å¦åˆ™è¿½åŠ 
                if (existingIndex !== -1) {
                    console.log(`[é™æ€çŸ¥è¯†åº“] è¦†ç›–å·²å­˜åœ¨çš„æ¡ç›®ï¼š${itemId}`);
                    this.staticKnowledgeBase[existingIndex] = newItem;
                } else {
                    this.staticKnowledgeBase.push(newItem);
                }
                
                importCount++;
            }
            
            console.log(`[é™æ€çŸ¥è¯†åº“] âœ… æˆåŠŸå¯¼å…¥ ${importCount} æ¡çŸ¥è¯†`);
            
            // ä¿å­˜åˆ°IndexedDB
            if (saveToIndexedDB) {
                await this.saveStaticKBToIndexedDB();
                console.log(`[é™æ€çŸ¥è¯†åº“] å·²ä¿å­˜åˆ°IndexedDBï¼ˆæŒä¹…åŒ–å­˜å‚¨ï¼‰`);
            } else {
                console.log(`[é™æ€çŸ¥è¯†åº“] è·³è¿‡IndexedDBä¿å­˜ï¼ˆä»…åœ¨å†…å­˜ï¼‰`);
            }
            
            return {
                success: true,
                count: importCount,
                total: this.staticKnowledgeBase.length
            };
            
        } catch (error) {
            console.error('[é™æ€çŸ¥è¯†åº“] å¯¼å…¥å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * ğŸ†• ç”Ÿæˆå‘é‡ï¼ˆæ ¹æ®å½“å‰è®¾ç½®ï¼‰
     */
    async generateVector(text) {
        if (this.embeddingMethod === 'keyword') {
            return this.createKeywordVector(text);
        } else if (this.embeddingMethod === 'api') {
            return await this.getEmbeddingFromAPI(text);
        } else if (this.embeddingMethod === 'transformers') {
            return await this.getEmbeddingFromTransformers(text);
        } else {
            return this.createKeywordVector(text);
        }
    }

    /**
     * ğŸ†• ä»é™æ€çŸ¥è¯†åº“æ£€ç´¢ç›¸å…³å†…å®¹ï¼ˆæ™ºèƒ½å…¼å®¹ç‰ˆï¼‰
     */
    async retrieveFromStaticKB(queryText, maxCount = 3) {
        if (!this.enableStaticKB || this.staticKnowledgeBase.length === 0) {
            console.log(`[é™æ€çŸ¥è¯†åº“] è·³è¿‡æ£€ç´¢ï¼š${!this.enableStaticKB ? 'æœªå¯ç”¨' : 'åº“ä¸ºç©º'}`);
            return [];
        }
        
        try {
            // ğŸ” è°ƒè¯•ä¿¡æ¯
            console.log(`[é™æ€çŸ¥è¯†åº“] å¼€å§‹æ£€ç´¢ï¼šæŸ¥è¯¢="${queryText}"ï¼Œåº“å¤§å°=${this.staticKnowledgeBase.length}`);
            
            // ğŸ†• è¿‡æ»¤æ‰ç³»ç»Ÿæ ‡ç­¾å’Œå¸¸é©»æ¡ç›®ï¼Œé¿å…é‡å¤ï¼ˆè¿™äº›å·²åœ¨P2.5/P3.5/P5ä¸­åŒ…å«ï¼‰
            const filteredKB = this.staticKnowledgeBase.filter(item => {
                // æ’é™¤å¸¸é©»æ¡ç›®ï¼ˆalwaysInclude === trueï¼‰
                if (item.alwaysInclude === true) {
                    return false;
                }
                
                // æ’é™¤ç³»ç»Ÿæ ‡ç­¾æ¡ç›®
                if (item.tags && Array.isArray(item.tags) && item.tags.includes('ç³»ç»Ÿ')) {
                    return false;
                }
                
                // æ’é™¤categoryä¸º"ç³»ç»Ÿ"çš„æ¡ç›®
                if (item.category === 'ç³»ç»Ÿ') {
                    return false;
                }
                
                return true;
            });
            
            const excludedCount = this.staticKnowledgeBase.length - filteredKB.length;
            if (excludedCount > 0) {
                console.log(`[é™æ€çŸ¥è¯†åº“] å·²æ’é™¤ ${excludedCount} æ¡ç³»ç»Ÿ/å¸¸é©»æ¡ç›®ï¼Œé¿å…é‡å¤ï¼ˆå‰©ä½™ ${filteredKB.length} æ¡å¯æ£€ç´¢ï¼‰`);
            }
            
            if (filteredKB.length === 0) {
                console.log(`[é™æ€çŸ¥è¯†åº“] è¿‡æ»¤åæ— å¯æ£€ç´¢æ¡ç›®`);
                return [];
            }
            
            // ğŸ”§ æ™ºèƒ½å‘é‡é€‰æ‹©ï¼šä¼˜å…ˆä½¿ç”¨å·²æœ‰å‘é‡ï¼Œå¦åˆ™ç”¨å…³é”®è¯
            // æ£€æµ‹çŸ¥è¯†åº“ä¸»è¦å‘é‡ç±»å‹
            const hasAnyDenseVector = filteredKB.some(item => item.vector && Array.isArray(item.vector));
            const useDenseQuery = hasAnyDenseVector && this.embeddingMethod === 'transformers';
            
            let queryVector;
            if (useDenseQuery) {
                // å¦‚æœçŸ¥è¯†åº“æœ‰ç¨ å¯†å‘é‡ä¸”å½“å‰æ–¹æ³•æ˜¯transformersï¼Œç”Ÿæˆç¨ å¯†æŸ¥è¯¢å‘é‡
                try {
                    queryVector = await this.getEmbeddingFromTransformers(queryText);
                    console.log(`[é™æ€çŸ¥è¯†åº“] æŸ¥è¯¢å‘é‡ç±»å‹ï¼šDenseï¼ˆç¨ å¯†ï¼‰ï¼Œç»´åº¦ï¼š${queryVector.length}`);
                } catch (error) {
                    console.warn('[é™æ€çŸ¥è¯†åº“] ç¨ å¯†å‘é‡ç”Ÿæˆå¤±è´¥ï¼Œå›é€€åˆ°å…³é”®è¯æ–¹æ³•');
                    queryVector = this.createKeywordVector(queryText);
                }
            } else {
                // é»˜è®¤ä½¿ç”¨å…³é”®è¯æ–¹æ³•
                queryVector = this.createKeywordVector(queryText);
                console.log(`[é™æ€çŸ¥è¯†åº“] æŸ¥è¯¢å‘é‡ç±»å‹ï¼šSparseï¼ˆå…³é”®è¯ï¼‰`);
                console.log(`[é™æ€çŸ¥è¯†åº“] æŸ¥è¯¢å‘é‡å…³é”®è¯æ•°: ${Object.keys(queryVector).length}`);
            }
            
            // è®¡ç®—ç›¸ä¼¼åº¦ï¼ˆæ™ºèƒ½åŒ¹é…å‘é‡ç±»å‹ï¼‰- ä½¿ç”¨è¿‡æ»¤åçš„çŸ¥è¯†åº“
            const similarities = filteredKB.map((item, index) => {
                let itemVector;
                let similarity = 0;
                
                // ğŸ”§ ä¼˜å…ˆä½¿ç”¨çŸ¥è¯†åº“å·²æœ‰çš„å‘é‡
                if (item.vector) {
                    itemVector = item.vector;
                } else {
                    // æ²¡æœ‰å‘é‡ï¼Œå®æ—¶ç”Ÿæˆå…³é”®è¯å‘é‡
                    itemVector = this.createKeywordVector(item.content);
                }
                
                // æ™ºèƒ½è®¡ç®—ç›¸ä¼¼åº¦ï¼ˆæ”¯æŒæ··åˆå‘é‡ç±»å‹ï¼‰
                const isQueryArray = Array.isArray(queryVector);
                const isItemArray = Array.isArray(itemVector);
                
                if (isQueryArray === isItemArray) {
                    // ç±»å‹åŒ¹é…ï¼Œç›´æ¥è®¡ç®—
                    similarity = this.calculateCosineSimilarity(queryVector, itemVector);
                } else {
                    // ç±»å‹ä¸åŒ¹é…ï¼Œè½¬æ¢ä¸ºå…³é”®è¯å‘é‡è®¡ç®—
                    if (isQueryArray && !isItemArray) {
                        // æŸ¥è¯¢æ˜¯Denseï¼ŒçŸ¥è¯†æ˜¯Sparse -> å°†æŸ¥è¯¢è½¬ä¸ºå…³é”®è¯
                        const keywordQuery = this.createKeywordVector(queryText);
                        similarity = this.calculateCosineSimilarity(keywordQuery, itemVector);
                    } else {
                        // æŸ¥è¯¢æ˜¯Sparseï¼ŒçŸ¥è¯†æ˜¯Dense -> å°†çŸ¥è¯†è½¬ä¸ºå…³é”®è¯
                        const keywordItem = this.createKeywordVector(item.content);
                        similarity = this.calculateCosineSimilarity(queryVector, keywordItem);
                    }
                }
                
                // ğŸ†• æ ‡é¢˜åŒ¹é…åŠ åˆ†ï¼ˆé€šç”¨ç‰ˆæœ¬ï¼‰
                if (item.title && queryText) {
                    const titleCore = item.title.replace('äººç‰©èƒŒæ™¯', '').trim();
                    
                    // å¦‚æœæŸ¥è¯¢æ–‡æœ¬å®Œå…¨åŒ…å«åœ¨æ ‡é¢˜ä¸­ï¼Œå¤§å¹…æé«˜ç›¸ä¼¼åº¦
                    if (item.title.includes(queryText) || queryText.includes(titleCore)) {
                        similarity += 0.5; // å®Œå…¨åŒ…å«åŠ åˆ†0.5
                        console.log(`[é™æ€çŸ¥è¯†åº“] æ ‡é¢˜åŒ¹é…åŠ åˆ†: ${item.title} â‰ˆ "${queryText}"`);
                    }
                    
                    // å¦‚æœæ ‡é¢˜æ ¸å¿ƒéƒ¨åˆ†å®Œå…¨åŒ¹é…æŸ¥è¯¢æ–‡æœ¬ï¼Œç»™äºˆæ›´é«˜åŠ åˆ†
                    if (titleCore === queryText) {
                        similarity += 0.8; // å®Œå…¨ç²¾ç¡®åŒ¹é…åŠ åˆ†0.8
                        console.log(`[é™æ€çŸ¥è¯†åº“] æ ‡é¢˜ç²¾ç¡®åŒ¹é…: ${titleCore}`);
                    }
                }
                
                return {
                    index: index,
                    similarity: similarity,
                    item: item,
                    vectorType: isItemArray ? 'dense' : 'sparse'
                };
            });
            
            // ğŸ” æ˜¾ç¤ºæ‰€æœ‰ç›¸ä¼¼åº¦ï¼ˆè°ƒè¯•ç”¨ï¼‰
            console.log(`[é™æ€çŸ¥è¯†åº“] ç›¸ä¼¼åº¦è®¡ç®—ç»“æœï¼š`);
            similarities.forEach((s, i) => {
                console.log(`  ${i+1}. [${s.item.category}] ${s.item.title} - ç›¸ä¼¼åº¦: ${s.similarity.toFixed(3)}`);
            });
            
            // è¿‡æ»¤å¹¶æ’åºï¼ˆé™ä½é˜ˆå€¼åˆ°0.1ï¼Œç¡®ä¿èƒ½åŒ¹é…åˆ°ï¼‰
            const threshold = this.minSimilarityThreshold * 0.5; // æ›´å®½æ¾çš„é˜ˆå€¼
            const results = similarities
                .filter(s => s.similarity >= threshold)
                .sort((a, b) => b.similarity - a.similarity)
                .slice(0, maxCount);
            
            console.log(`[é™æ€çŸ¥è¯†åº“] âœ… æ£€ç´¢åˆ° ${results.length} æ¡ç›¸å…³çŸ¥è¯†ï¼ˆé˜ˆå€¼ï¼š${threshold.toFixed(2)}ï¼‰`);
            
            // ğŸ†• è¯¦ç»†æ˜¾ç¤ºé€‰ä¸­çš„æ¡ç›®
            if (results.length > 0) {
                console.log(`[é™æ€çŸ¥è¯†åº“] ğŸ“‹ é€‰ä¸­æ¡ç›®è¯¦æƒ…ï¼š`);
                results.forEach((result, index) => {
                    console.log(`  â”Œâ”€ æ¡ç›® ${index + 1}`);
                    console.log(`  â”‚  æ ‡é¢˜: ${result.item.title}`);
                    console.log(`  â”‚  åˆ†ç±»: ${result.item.category}`);
                    console.log(`  â”‚  ç›¸ä¼¼åº¦: ${(result.similarity * 100).toFixed(1)}%`);
                    console.log(`  â”‚  å‘é‡ç±»å‹: ${result.vectorType}`);
                    // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
                    let contentPreview = result.item.content;
                    if (typeof result.item.content === 'object' && result.item.content !== null) {
                        contentPreview = JSON.stringify(result.item.content, null, 2);
                    }
                    console.log(`  â”‚  å†…å®¹é¢„è§ˆ: ${contentPreview.substring(0, 50)}...`);
                    console.log(`  â””â”€`);
                });
            }
            
            if (results.length === 0) {
                console.warn(`[é™æ€çŸ¥è¯†åº“] âš ï¸ æœªæ‰¾åˆ°åŒ¹é…å†…å®¹ï¼ŒåŸå› å¯èƒ½æ˜¯ï¼š`);
                console.warn(`  1. å‘é‡ç±»å‹ä¸å…¼å®¹ï¼ˆåº“ç±»å‹ä¸æŸ¥è¯¢ç±»å‹ä¸åŒï¼‰`);
                console.warn(`  2. ç›¸ä¼¼åº¦é˜ˆå€¼è¿‡é«˜ï¼ˆå½“å‰ï¼š${threshold.toFixed(2)}ï¼‰`);
                console.warn(`  3. æ ‡ç­¾æˆ–å†…å®¹ä¸åŒ¹é…`);
                console.warn(`  å»ºè®®ï¼šåœ¨æ§åˆ¶å°æ‰§è¡Œ testKBRetrieval() è¿›è¡Œè°ƒè¯•`);
            }
            
            return results.map(r => ({
                id: r.item.id,
                title: r.item.title,
                content: r.item.content,
                category: r.item.category,
                tags: r.item.tags,
                similarity: r.similarity,
                isPriority: r.item.isPriority || false, // ğŸ†• ä¼ é€’é‡ç‚¹æ ‡è®°
                metadata: r.item.metadata
            }));
            
        } catch (error) {
            console.error('[é™æ€çŸ¥è¯†åº“] æ£€ç´¢å¤±è´¥:', error);
            return [];
        }
    }

    /**
     * ä¿å­˜å‘é‡åº“åˆ°IndexedDB
     */
    async saveToIndexedDB(dbName = 'xiuxian_vector_db') {
        try {
            const db = await this.openVectorDB(dbName);
            
            // ä¿å­˜å¯¹è¯å‘é‡åº“
            const transaction1 = db.transaction(['embeddings'], 'readwrite');
            const store1 = transaction1.objectStore('embeddings');
            
            await store1.clear();
            await store1.put({
                id: 'main',
                embeddings: this.conversationEmbeddings,
                timestamp: Date.now()
            });
            
            // ğŸ†• ä¿å­˜historyå‘é‡åº“
            const transaction2 = db.transaction(['historyEmbeddings'], 'readwrite');
            const store2 = transaction2.objectStore('historyEmbeddings');
            
            await store2.clear();
            await store2.put({
                id: 'main',
                historyEmbeddings: this.historyEmbeddings,
                timestamp: Date.now()
            });
            
            console.log(`[å‘é‡åº“] å·²ä¿å­˜åˆ°IndexedDBï¼ˆå¯¹è¯:${this.conversationEmbeddings.length}æ¡, History:${this.historyEmbeddings.length}æ¡ï¼‰`);
        } catch (error) {
            console.error('[å‘é‡åº“] ä¿å­˜å¤±è´¥:', error);
        }
    }

    /**
     * ä»IndexedDBåŠ è½½å‘é‡åº“
     */
    async loadFromIndexedDB(dbName = 'xiuxian_vector_db') {
        try {
            const db = await this.openVectorDB(dbName);
            
            // åŠ è½½å¯¹è¯å‘é‡åº“
            const transaction1 = db.transaction(['embeddings'], 'readonly');
            const store1 = transaction1.objectStore('embeddings');
            
            const request1 = store1.get('main');
            const result1 = await new Promise((resolve, reject) => {
                request1.onsuccess = () => resolve(request1.result);
                request1.onerror = () => reject(request1.error);
            });
            
            if (result1 && result1.embeddings) {
                this.conversationEmbeddings = result1.embeddings;
                
                // ğŸ”§ é‡è¦ï¼šé‡æ–°æ‘„å…¥å¯¹è¯å‘é‡åˆ°conversationMatrix
                if (window.matrixManager && window.matrixManager.conversationMatrix) {
                    console.log(`[å¯¹è¯çŸ©é˜µ] ğŸ”„ é‡æ–°æ‘„å…¥ ${this.conversationEmbeddings.length} æ¡å¯¹è¯åˆ°çŸ©é˜µ...`);
                    let ingestedCount = 0;
                    for (const conv of this.conversationEmbeddings) {
                        try {
                            window.matrixManager.conversationMatrix.ingestVector(conv.vector, {
                                userMessage: conv.userMessage,
                                aiResponse: conv.aiResponse,
                                turnIndex: conv.turnIndex,
                                timestamp: conv.timestamp
                            });
                            ingestedCount++;
                        } catch (error) {
                            console.warn(`[å¯¹è¯çŸ©é˜µ] âš ï¸ æ‘„å…¥å¤±è´¥: ç¬¬${conv.turnIndex}è½®`, error);
                        }
                    }
                    console.log(`[å¯¹è¯çŸ©é˜µ] âœ… å·²é‡æ–°æ‘„å…¥ ${ingestedCount} æ¡å¯¹è¯åˆ°çŸ©é˜µ`);
                } else {
                    console.warn('[å¯¹è¯çŸ©é˜µ] âš ï¸ çŸ©é˜µç®¡ç†å™¨æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ‘„å…¥å¯¹è¯');
                }
            }
            
            // ğŸ†• åŠ è½½historyå‘é‡åº“
            const transaction2 = db.transaction(['historyEmbeddings'], 'readonly');
            const store2 = transaction2.objectStore('historyEmbeddings');
            
            const request2 = store2.get('main');
            const result2 = await new Promise((resolve, reject) => {
                request2.onsuccess = () => resolve(request2.result);
                request2.onerror = () => reject(request2.error);
            });
            
            if (result2 && result2.historyEmbeddings) {
                this.historyEmbeddings = result2.historyEmbeddings;
                
                // ğŸ”§ é‡è¦ï¼šé‡æ–°æ‘„å…¥historyEmbeddingsåˆ°historyMatrix
                if (window.matrixManager && window.matrixManager.historyMatrix) {
                    console.log(`[HistoryçŸ©é˜µ] ğŸ”„ é‡æ–°æ‘„å…¥ ${this.historyEmbeddings.length} æ¡historyåˆ°çŸ©é˜µ...`);
                    let ingestedCount = 0;
                    for (const entry of this.historyEmbeddings) {
                        try {
                            window.matrixManager.historyMatrix.ingestVector({
                                vector: entry.vector,
                                aiResponse: entry.content,  // ğŸ”§ ä¿®å¤ï¼šä½¿ç”¨aiResponseå­—æ®µè€Œä¸æ˜¯content
                                turnIndex: entry.turnIndex,
                                timestamp: entry.timestamp
                            });
                            ingestedCount++;
                        } catch (error) {
                            console.warn(`[HistoryçŸ©é˜µ] âš ï¸ æ‘„å…¥å¤±è´¥:`, entry.content?.substring(0, 30), error);
                        }
                    }
                    console.log(`[HistoryçŸ©é˜µ] âœ… å·²é‡æ–°æ‘„å…¥ ${ingestedCount} æ¡historyåˆ°çŸ©é˜µ`);
                } else {
                    console.warn('[HistoryçŸ©é˜µ] âš ï¸ çŸ©é˜µç®¡ç†å™¨æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ‘„å…¥history');
                }
            }
            
            console.log(`[å‘é‡åº“] å·²ä»IndexedDBåŠ è½½ï¼ˆå¯¹è¯:${this.conversationEmbeddings.length}æ¡, History:${this.historyEmbeddings.length}æ¡ï¼‰`);
        } catch (error) {
            console.error('[å‘é‡åº“] åŠ è½½å¤±è´¥:', error);
        }
    }

    /**
     * ğŸ†• ä¿å­˜é™æ€çŸ¥è¯†åº“åˆ°IndexedDB
     */
    async saveStaticKBToIndexedDB(dbName = 'xiuxian_vector_db') {
        try {
            const db = await this.openVectorDB(dbName);
            const transaction = db.transaction(['staticKB'], 'readwrite');
            const store = transaction.objectStore('staticKB');
            
            await store.clear();
            await store.put({
                id: 'main',
                knowledge: this.staticKnowledgeBase,
                timestamp: Date.now()
            });
            
            console.log(`[é™æ€çŸ¥è¯†åº“] å·²ä¿å­˜ ${this.staticKnowledgeBase.length} æ¡åˆ°IndexedDB`);
        } catch (error) {
            console.error('[é™æ€çŸ¥è¯†åº“] ä¿å­˜å¤±è´¥:', error);
        }
    }

    /**
     * ğŸ†• ä»IndexedDBåŠ è½½é™æ€çŸ¥è¯†åº“
     */
    async loadStaticKBFromIndexedDB(dbName = 'xiuxian_vector_db') {
        try {
            const db = await this.openVectorDB(dbName);
            const transaction = db.transaction(['staticKB'], 'readonly');
            const store = transaction.objectStore('staticKB');
            
            const request = store.get('main');
            const result = await new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
            
            if (result && result.knowledge) {
                this.staticKnowledgeBase = result.knowledge;
                console.log(`[é™æ€çŸ¥è¯†åº“] å·²ä»IndexedDBåŠ è½½ ${this.staticKnowledgeBase.length} æ¡çŸ¥è¯†`);
            }
        } catch (error) {
            console.error('[é™æ€çŸ¥è¯†åº“] åŠ è½½å¤±è´¥:', error);
        }
    }

    /**
     * ğŸ†• æ¸…ç©ºé™æ€çŸ¥è¯†åº“
     */
    clearStaticKB() {
        this.staticKnowledgeBase = [];
        console.log('[é™æ€çŸ¥è¯†åº“] å·²æ¸…ç©º');
    }

    /**
     * ğŸ†• æ¸…ç©ºIndexedDBä¸­çš„å‘é‡æ•°æ®
     */
    async clearIndexedDB(dbName = 'xiuxian_vector_db') {
        try {
            const db = await this.openVectorDB(dbName);
            
            // æ¸…ç©ºæ‰€æœ‰å­˜å‚¨
            const embeddingsTransaction = db.transaction(['embeddings'], 'readwrite');
            const embeddingsStore = embeddingsTransaction.objectStore('embeddings');
            await embeddingsStore.clear();
            
            const staticKBTransaction = db.transaction(['staticKB'], 'readwrite');
            const staticKBStore = staticKBTransaction.objectStore('staticKB');
            await staticKBStore.clear();
            
            console.log('[å‘é‡ç®¡ç†å™¨] å·²æ¸…ç©ºIndexedDBä¸­çš„æ‰€æœ‰æ•°æ®');
        } catch (error) {
            console.error('[å‘é‡ç®¡ç†å™¨] æ¸…ç©ºIndexedDBå¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * ğŸ†• å¯¼å‡ºé™æ€çŸ¥è¯†åº“ä¸ºJSON
     */
    exportStaticKB() {
        return {
            version: '1.0',
            timestamp: Date.now(),
            method: this.embeddingMethod,
            knowledge: this.staticKnowledgeBase
        };
    }

    /**
     * ğŸ†• å¯¼å‡ºå¯¹è¯å‘é‡åº“
     */
    exportConversationVectors() {
        return {
            version: '1.0',
            timestamp: Date.now(),
            method: this.embeddingMethod,
            embeddings: this.conversationEmbeddings
        };
    }

    /**
     * ğŸ†• å¯¼å…¥å¯¹è¯å‘é‡åº“
     */
    async importConversationVectors(data) {
        try {
            const embeddings = Array.isArray(data) ? data : (data.embeddings || []);
            this.conversationEmbeddings = embeddings;
            
            // ä¿å­˜åˆ°IndexedDB
            await this.saveToIndexedDB();
            
            console.log(`[å¯¹è¯å‘é‡åº“] âœ… æˆåŠŸå¯¼å…¥ ${embeddings.length} æ¡å‘é‡`);
            return {
                success: true,
                count: embeddings.length
            };
        } catch (error) {
            console.error('[å¯¹è¯å‘é‡åº“] å¯¼å…¥å¤±è´¥:', error);
            throw error;
        }
    }

    /**
     * æ‰“å¼€å‘é‡æ•°æ®åº“
     */
    openVectorDB(dbName) {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(dbName, 3); // ç‰ˆæœ¬å·å‡çº§åˆ°3ï¼ˆæ–°å¢historyEmbeddingsï¼‰
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // å¯¹è¯å†å²å‘é‡åº“
                if (!db.objectStoreNames.contains('embeddings')) {
                    db.createObjectStore('embeddings', { keyPath: 'id' });
                }
                
                // ğŸ†• é™æ€çŸ¥è¯†åº“
                if (!db.objectStoreNames.contains('staticKB')) {
                    db.createObjectStore('staticKB', { keyPath: 'id' });
                }
                
                // ğŸ†• historyä¸“ç”¨å‘é‡åº“
                if (!db.objectStoreNames.contains('historyEmbeddings')) {
                    db.createObjectStore('historyEmbeddings', { keyPath: 'id' });
                }
            };
        });
    }
    
    /**
     * ğŸ†• ä»AIå›å¤ä¸­æå–å¹¶å‘é‡åŒ–history
     * @param {Array} historyArray - AIå›å¤ä¸­çš„historyæ•°ç»„
     * @param {number} turnIndex - å½“å‰å¯¹è¯è½®æ¬¡
     */
    async addHistoryToVectorLib(historyArray, turnIndex) {
        if (!historyArray || !Array.isArray(historyArray) || historyArray.length === 0) {
            return;
        }
        
        console.log(`[Historyå‘é‡åŒ–] ç¬¬${turnIndex}è½®åŒ…å«${historyArray.length}æ¡history`);
        
        for (let i = 0; i < historyArray.length; i++) {
            const historyText = historyArray[i];
            
            if (!historyText || typeof historyText !== 'string' || historyText.length < 10) {
                continue; // è·³è¿‡æ— æ•ˆæˆ–å¤ªçŸ­çš„history
            }
            
            try {
                let vector;
                
                // ä½¿ç”¨ä¸å¯¹è¯ç›¸åŒçš„å‘é‡åŒ–æ–¹æ³•
                if (this.embeddingMethod === 'keyword') {
                    vector = this.createKeywordVector(historyText);
                } else if (this.embeddingMethod === 'api') {
                    vector = await this.getEmbeddingFromAPI(historyText);
                } else if (this.embeddingMethod === 'transformers') {
                    vector = await this.getEmbeddingFromTransformers(historyText);
                } else {
                    vector = this.createKeywordVector(historyText);
                }
                
                // éªŒè¯å‘é‡
                if (!vector || (Array.isArray(vector) && vector.length === 0) || (typeof vector === 'object' && Object.keys(vector).length === 0)) {
                    console.warn(`[Historyå‘é‡åŒ–] ç¬¬${turnIndex}è½®ç¬¬${i}æ¡historyå‘é‡ç”Ÿæˆå¤±è´¥ï¼Œè·³è¿‡`);
                    continue;
                }
                
                // ç”Ÿæˆå”¯ä¸€IDï¼ˆåŸºäºè½®æ¬¡å’Œç´¢å¼•ï¼‰
                const historyId = `${turnIndex}-${i}`;
                
                // æ·»åŠ åˆ°historyå‘é‡åº“
                this.historyEmbeddings.push({
                    id: historyId,
                    turnIndex: turnIndex,
                    historyIndex: i,
                    content: historyText,
                    vector: vector,
                    vectorType: Array.isArray(vector) ? 'dense' : 'sparse',
                    timestamp: Date.now()
                });
                
            } catch (error) {
                console.error(`[Historyå‘é‡åŒ–] ç¬¬${turnIndex}è½®ç¬¬${i}æ¡å¤„ç†å¤±è´¥:`, error);
            }
        }
        
        console.log(`[Historyå‘é‡åº“] å½“å‰æ€»æ•°ï¼š${this.historyEmbeddings.length}æ¡`);
    }
    
    /**
     * ğŸ†• è·å–æœ€è¿‘Næ¡historyï¼ˆä¸é€šè¿‡å‘é‡æ£€ç´¢ï¼‰
     * @param {number} count - éœ€è¦å¤šå°‘æ¡
     * @returns {Array} historyæ–‡æœ¬æ•°ç»„
     */
    getRecentHistory(count = 30) {
        if (this.historyEmbeddings.length === 0) {
            return [];
        }
        
        // æŒ‰turnIndexå’ŒhistoryIndexæ’åºï¼Œå–æœ€æ–°çš„
        const sorted = [...this.historyEmbeddings].sort((a, b) => {
            if (a.turnIndex !== b.turnIndex) {
                return b.turnIndex - a.turnIndex; // è½®æ¬¡é™åº
            }
            return b.historyIndex - a.historyIndex; // åŒè½®æ¬¡å†…ç´¢å¼•é™åº
        });
        
        // ğŸ”§ å»é‡ï¼šä½¿ç”¨Setç¡®ä¿æ²¡æœ‰é‡å¤å†…å®¹
        const seen = new Set();
        const unique = [];
        for (const h of sorted) {
            const trimmed = h.content.trim();
            if (!seen.has(trimmed) && trimmed) {
                seen.add(trimmed);
                unique.push(h.content);
                if (unique.length >= count) break;
            }
        }
        
        return unique;
    }
    
    /**
     * ğŸ†• é€šè¿‡çŸ©é˜µæ£€ç´¢ç›¸å…³history
     * @param {string} query - æŸ¥è¯¢æ–‡æœ¬
     * @param {number} count - éœ€è¦å¤šå°‘æ¡
     * @returns {Array} historyæ–‡æœ¬æ•°ç»„
     */
    async retrieveHistoryByMatrix(query, count = 15) {
        if (!window.matrixManager || !window.matrixManager.historyMatrix) {
            console.warn('[HistoryçŸ©é˜µæ£€ç´¢] çŸ©é˜µç®¡ç†å™¨æœªåˆå§‹åŒ–');
            return [];
        }
        
        // ğŸ†• å¦‚æœé…ç½®äº†åŒ…å«AIå›å¤ï¼Œåˆ™å¢å¼ºæŸ¥è¯¢
        let enhancedQuery = query;
        if (this.includeRecentAIRepliesInQuery > 0) {
            const conversationHistory = window.gameState?.conversationHistory || [];
            if (conversationHistory.length > 0) {
                const recentAIReplies = conversationHistory
                    .filter(msg => msg.role === 'assistant')
                    .slice(-this.includeRecentAIRepliesInQuery)
                    .map(msg => msg.content);
                
                if (recentAIReplies.length > 0) {
                    enhancedQuery = query + '\n' + recentAIReplies.join('\n') + '\n' + query + '\n' + query;
                    console.log(`[HistoryçŸ©é˜µæ£€ç´¢] âœ… å·²åŒ…å«æœ€è¿‘${recentAIReplies.length}è½®AIå›å¤`);
                }
            }
        }
        
        // ä½¿ç”¨å¢å¼ºåçš„æŸ¥è¯¢è¿›è¡ŒçŸ©é˜µæ£€ç´¢
        const results = window.matrixManager.historyMatrix.searchByMatrix(enhancedQuery, count * 2);
        
        // ğŸ”§ ä¿®å¤ï¼šçŸ©é˜µä¸­å­˜å‚¨çš„æ˜¯ {aiResponse, ...} æ ¼å¼ï¼Œè€Œä¸æ˜¯ {content}
        // ğŸ”§ å»é‡ï¼šç¡®ä¿çŸ©é˜µæ£€ç´¢ç»“æœæœ¬èº«æ²¡æœ‰é‡å¤
        const seen = new Set();
        const unique = [];
        for (const r of results) {
            if (r && r.aiResponse) {
                const trimmed = r.aiResponse.trim();
                if (!seen.has(trimmed) && trimmed) {
                    seen.add(trimmed);
                    unique.push(r.aiResponse);
                    if (unique.length >= count) break;
                }
            }
        }
        
        return unique;
    }
    
    /**
     * ğŸ†• æ„å»ºhistoryä¸Šä¸‹æ–‡ï¼ˆ30æ¡æœ€è¿‘ + 15æ¡çŸ©é˜µæ£€ç´¢ï¼‰
     * @param {string} query - æŸ¥è¯¢æ–‡æœ¬ï¼ˆç”¨äºçŸ©é˜µæ£€ç´¢ï¼‰
     * @returns {Object} { recent: [], matrix: [] }
     */
    async buildHistoryContext(query) {
        const recentHistory = this.getRecentHistory(this.recentHistoryCount);
        const matrixHistory = await this.retrieveHistoryByMatrix(query, this.matrixHistoryCount);
        
        // ğŸ”§ å»é‡ï¼šä»çŸ©é˜µæ£€ç´¢ç»“æœä¸­ç§»é™¤å·²ç»åœ¨æœ€è¿‘historyä¸­å‡ºç°çš„æ¡ç›®
        const recentSet = new Set(recentHistory.map(h => h.trim()));
        const uniqueMatrixHistory = matrixHistory.filter(h => !recentSet.has(h.trim()));
        
        console.log(`[Historyä¸Šä¸‹æ–‡] æœ€è¿‘${recentHistory.length}æ¡ + çŸ©é˜µæ£€ç´¢${matrixHistory.length}æ¡ï¼ˆå»é‡å${uniqueMatrixHistory.length}æ¡ï¼‰`);
        
        return {
            recent: recentHistory,
            matrix: uniqueMatrixHistory
        };
    }
    
    /**
     * ğŸ†• æ¸…ç©ºhistoryå‘é‡åº“
     */
    clearHistoryEmbeddings() {
        this.historyEmbeddings = [];
        console.log('[Historyå‘é‡åº“] å·²æ¸…ç©º');
    }
}

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šåŠ è½½é™æ€çŸ¥è¯†åº“æ–‡ä»¶ï¼ˆé»˜è®¤ä¿å­˜åˆ°IndexedDBï¼‰
window.loadKnowledgeBase = async function(filePath) {
    try {
        const result = await window.contextVectorManager.loadStaticKnowledgeFromFile(filePath, false);
        
        // ç»Ÿè®¡å‘é‡ç±»å‹
        const kb = window.contextVectorManager.staticKnowledgeBase;
        const denseCount = kb.filter(item => item.vector && Array.isArray(item.vector)).length;
        const sparseCount = kb.filter(item => item.vector && !Array.isArray(item.vector)).length;
        const lazyCount = kb.filter(item => !item.vector).length;
        
        alert(`âœ… çŸ¥è¯†åº“åŠ è½½æˆåŠŸï¼\n\n` +
              `ğŸ“Š ç»Ÿè®¡ï¼š\n` +
              `- å¯¼å…¥ï¼š${result.count} æ¡\n` +
              `- æ€»è®¡ï¼š${result.total} æ¡\n\n` +
              `ğŸ”¢ å‘é‡ç±»å‹ï¼š\n` +
              `- ç¨ å¯†å‘é‡ï¼ˆDenseï¼‰ï¼š${denseCount} æ¡\n` +
              `- ç¨€ç–å‘é‡ï¼ˆSparseï¼‰ï¼š${sparseCount} æ¡\n` +
              `- å»¶è¿Ÿç”Ÿæˆï¼ˆLazyï¼‰ï¼š${lazyCount} æ¡\n\n` +
              `ğŸ’¾ å·²ä¿å­˜åˆ°ï¼šIndexedDB`);
        return result;
    } catch (error) {
        alert(`âŒ çŸ¥è¯†åº“åŠ è½½å¤±è´¥ï¼š${error.message}`);
        throw error;
    }
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šä»ç”¨æˆ·é€‰æ‹©çš„æ–‡ä»¶å¯¼å…¥çŸ¥è¯†åº“
window.importKnowledgeBase = function() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        try {
            const text = await file.text();
            const data = JSON.parse(text);
            
            // é»˜è®¤ä¿å­˜åˆ°IndexedDB
            const result = await window.contextVectorManager.importStaticKnowledge(data, false, true);
            
            // ç»Ÿè®¡å‘é‡ç±»å‹
            const kb = window.contextVectorManager.staticKnowledgeBase;
            const denseCount = kb.filter(item => item.vector && Array.isArray(item.vector)).length;
            const sparseCount = kb.filter(item => item.vector && !Array.isArray(item.vector)).length;
            const lazyCount = kb.filter(item => !item.vector).length;
            
            alert(`âœ… çŸ¥è¯†åº“å¯¼å…¥æˆåŠŸï¼\n\n` +
                  `ğŸ“Š ç»Ÿè®¡ï¼š\n` +
                  `- å¯¼å…¥ï¼š${result.count} æ¡\n` +
                  `- æ€»è®¡ï¼š${result.total} æ¡\n\n` +
                  `ğŸ”¢ å‘é‡ç±»å‹ï¼š\n` +
                  `- ç¨ å¯†å‘é‡ï¼ˆDenseï¼‰ï¼š${denseCount} æ¡\n` +
                  `- ç¨€ç–å‘é‡ï¼ˆSparseï¼‰ï¼š${sparseCount} æ¡\n` +
                  `- å»¶è¿Ÿç”Ÿæˆï¼ˆLazyï¼‰ï¼š${lazyCount} æ¡\n\n` +
                  `ğŸ’¾ å·²ä¿å­˜åˆ°ï¼šIndexedDB (xiuxian_vector_db â†’ staticKB)\n\n` +
                  `ğŸ’¡ ç‚¹å‡»"æŸ¥çœ‹å‘é‡çŠ¶æ€"å¯æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯`);
        } catch (error) {
            alert(`âŒ å¯¼å…¥å¤±è´¥ï¼š${error.message}`);
        }
    };
    
    input.click();
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šå¯¼å‡ºé™æ€çŸ¥è¯†åº“
window.exportKnowledgeBase = function() {
    const data = window.contextVectorManager.exportStaticKB();
    
    const dataStr = JSON.stringify(data, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `çŸ¥è¯†åº“_${new Date().toLocaleString('zh-CN').replace(/[/:]/g, '-')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    alert(`âœ… çŸ¥è¯†åº“å·²å¯¼å‡ºï¼\nåŒ…å« ${data.knowledge.length} æ¡çŸ¥è¯†`);
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šæŸ¥çœ‹é™æ€çŸ¥è¯†åº“
window.showKnowledgeBase = function() {
    const kb = window.contextVectorManager.staticKnowledgeBase;
    
    if (kb.length === 0) {
        console.log('é™æ€çŸ¥è¯†åº“ä¸ºç©º');
        return;
    }
    
    // ç»Ÿè®¡ç±»å‹
    const alwaysCount = kb.filter(item => item.alwaysInclude === true).length;
    const denseCount = kb.filter(item => item.vector && Array.isArray(item.vector)).length;
    const sparseCount = kb.filter(item => item.vector && !Array.isArray(item.vector)).length;
    const lazyCount = kb.filter(item => !item.vector && !item.alwaysInclude).length;
    
    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘  ğŸ“š é™æ€çŸ¥è¯†åº“                                  â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log(`â•‘  æ€»æ¡æ•°ï¼š${kb.length}                              â•‘`);
    console.log(`â•‘  â­å¸¸é©»çŸ¥è¯†ï¼š${alwaysCount}æ¡                          â•‘`);
    console.log(`â•‘  ğŸ”¢ç¨ å¯†å‘é‡ï¼š${denseCount}æ¡                           â•‘`);
    console.log(`â•‘  ğŸ“Šç¨€ç–å‘é‡ï¼š${sparseCount}æ¡                           â•‘`);
    console.log(`â•‘  â³å»¶è¿Ÿç”Ÿæˆï¼š${lazyCount}æ¡                           â•‘`);
    console.log(`â•‘  å½“å‰æ£€ç´¢æ–¹æ³•ï¼š${window.contextVectorManager.embeddingMethod}       â•‘`);
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    
    kb.forEach((item, index) => {
        let prefix = item.alwaysInclude ? 'â­' : '  ';
        let vectorType = '';
        if (item.alwaysInclude) {
            vectorType = 'å¸¸é©»ï¼ˆæ— éœ€å‘é‡ï¼‰';
        } else if (item.vector) {
            vectorType = Array.isArray(item.vector) ? `Dense(${item.vector.length})` : `Sparse(${Object.keys(item.vector).length})`;
        } else {
            vectorType = 'Lazy';
        }
        
        console.log(`${prefix}${index + 1}. [${item.category}] ${item.title} (${vectorType})`);
        // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
        let contentDisplay = item.content;
        if (typeof item.content === 'object' && item.content !== null) {
            contentDisplay = JSON.stringify(item.content, null, 2);
        }
        console.log(`     ${contentDisplay.substring(0, 60)}...`);
        if (item.tags.length > 0) {
            console.log(`     æ ‡ç­¾: ${item.tags.join(', ')}`);
        }
    });
    
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(`\nğŸ’¡ æç¤ºï¼š\n- â­æ ‡è®°çš„æ˜¯å¸¸é©»çŸ¥è¯†ï¼ˆæ¯æ¬¡éƒ½ç”Ÿæ•ˆï¼‰\n- Dense/Sparseæ˜¯æœ‰å‘é‡çš„çŸ¥è¯†ï¼ˆéœ€æ£€ç´¢åŒ¹é…ï¼‰\n- Lazyæ˜¯å»¶è¿Ÿç”Ÿæˆï¼ˆæ£€ç´¢æ—¶å®æ—¶è®¡ç®—ï¼‰`);
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šå¿«é€Ÿæµ‹è¯•é™æ€çŸ¥è¯†åº“æ£€ç´¢
window.testStaticKB = async function(keyword) {
    if (!keyword) {
        keyword = prompt('è¯·è¾“å…¥æµ‹è¯•å…³é”®è¯ï¼ˆå¦‚ï¼šé’äº‘å®—ï¼‰ï¼š');
        if (!keyword) return;
    }
    
    console.log(`\n[æµ‹è¯•æ£€ç´¢] å…³é”®è¯ï¼š${keyword}`);
    console.log(`[æµ‹è¯•æ£€ç´¢] å½“å‰å‘é‡åŒ–æ–¹æ³•ï¼š${window.contextVectorManager.embeddingMethod}`);
    console.log(`[æµ‹è¯•æ£€ç´¢] çŸ¥è¯†åº“å¤§å°ï¼š${window.contextVectorManager.staticKnowledgeBase.length}æ¡`);
    
    const results = await window.contextVectorManager.retrieveFromStaticKB(keyword, 5);
    
    if (results.length === 0) {
        console.warn('âŒ æœªæ‰¾åˆ°åŒ¹é…å†…å®¹ï¼');
        console.warn('å»ºè®®ï¼š');
        console.warn('  1. æ£€æŸ¥çŸ¥è¯†åº“æ˜¯å¦å¯¼å…¥æˆåŠŸï¼šshowKnowledgeBase()');
        console.warn('  2. æŸ¥çœ‹å‘é‡ç±»å‹æ˜¯å¦åŒ¹é…');
        console.warn('  3. é™ä½ç›¸ä¼¼åº¦é˜ˆå€¼');
        return;
    }
    
    console.log(`\nâœ… æ‰¾åˆ° ${results.length} æ¡åŒ¹é…ï¼š\n`);
    results.forEach((item, i) => {
        console.log(`${i+1}. [${item.category}] ${item.title}`);
        console.log(`   ç›¸ä¼¼åº¦ï¼š${(item.similarity * 100).toFixed(2)}%`);
        // å¤„ç†contentä¸ºå¯¹è±¡çš„æƒ…å†µ
        let contentText = item.content;
        if (typeof item.content === 'object' && item.content !== null) {
            contentText = JSON.stringify(item.content, null, 2);
        }
        console.log(`   å†…å®¹ï¼š${contentText.substring(0, 80)}...`);
        console.log('');
    });
    
    return results;
};

// åˆ›å»ºå…¨å±€å®ä¾‹
window.contextVectorManager = new ContextVectorManager();

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šåˆ‡æ¢æ¨¡å‹æ¥æºï¼ˆå¯åœ¨æ§åˆ¶å°è°ƒç”¨ï¼‰
window.useLocalModel = function(enable = true) {
    window.contextVectorManager.modelConfig.useLocalModel = enable;
    console.log(`[æ¨¡å‹é…ç½®] ${enable ? 'âœ… å·²åˆ‡æ¢åˆ°æœ¬åœ°æ¨¡å‹' : 'ğŸ“¡ å·²åˆ‡æ¢åˆ°CDNæ¨¡å‹'}`);
    console.log(`[æ¨¡å‹é…ç½®] è·¯å¾„ï¼š${enable ? window.contextVectorManager.modelConfig.localModelPath : window.contextVectorManager.modelConfig.cdnModelName}`);
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šåˆ‡æ¢é‡åŒ–æ¨¡å‹ï¼ˆå¯åœ¨æ§åˆ¶å°è°ƒç”¨ï¼‰
window.useQuantizedModel = function(enable = true) {
    window.contextVectorManager.modelConfig.useQuantized = enable;
    console.log(`[æ¨¡å‹é…ç½®] ${enable ? 'âœ… å·²å¯ç”¨é‡åŒ–æ¨¡å‹ï¼ˆ13MBï¼‰' : 'ğŸ“¦ å·²åˆ‡æ¢åˆ°æ ‡å‡†æ¨¡å‹ï¼ˆ50MBï¼‰'}`);
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šè®¾ç½®è‡ªå®šä¹‰æ¨¡å‹è·¯å¾„ï¼ˆå¯åœ¨æ§åˆ¶å°è°ƒç”¨ï¼‰
window.setModelPath = function(path) {
    window.contextVectorManager.modelConfig.localModelPath = path;
    console.log(`[æ¨¡å‹é…ç½®] âœ… æœ¬åœ°æ¨¡å‹è·¯å¾„å·²æ›´æ–°ä¸ºï¼š${path}`);
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šæŸ¥çœ‹å½“å‰æ¨¡å‹é…ç½®
window.showModelConfig = function() {
    const config = window.contextVectorManager.modelConfig;
    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘  ğŸ¤– æµè§ˆå™¨æ¨¡å‹é…ç½®                              â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log(`â•‘  ä½¿ç”¨æœ¬åœ°æ¨¡å‹ï¼š${config.useLocalModel ? 'âœ… æ˜¯' : 'âŒ å¦'}                          â•‘`);
    console.log(`â•‘  æœ¬åœ°è·¯å¾„ï¼š${config.localModelPath.padEnd(30)}â•‘`);
    console.log(`â•‘  CDNåç§°ï¼š${config.cdnModelName.padEnd(31)}â•‘`);
    console.log(`â•‘  é‡åŒ–æ¨¡å‹ï¼š${config.useQuantized ? 'âœ… å¯ç”¨ï¼ˆ13MBï¼‰' : 'âŒ ç¦ç”¨ï¼ˆ50MBï¼‰'}                  â•‘`);
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log('â•‘  ğŸ’¡ æ§åˆ¶å°å‘½ä»¤ï¼š                                â•‘');
    console.log('â•‘    useLocalModel(true)  - ä½¿ç”¨æœ¬åœ°æ¨¡å‹         â•‘');
    console.log('â•‘    useLocalModel(false) - ä½¿ç”¨CDNæ¨¡å‹          â•‘');
    console.log('â•‘    useQuantizedModel(true)  - å¯ç”¨é‡åŒ–ï¼ˆå¿«ï¼‰   â•‘');
    console.log('â•‘    useQuantizedModel(false) - ä½¿ç”¨æ ‡å‡†ï¼ˆç²¾ç¡®ï¼‰ â•‘');
    console.log('â•‘    setModelPath("./models/xxx") - è‡ªå®šä¹‰è·¯å¾„   â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šæŸ¥çœ‹IndexedDBä¸­å­˜å‚¨çš„é™æ€çŸ¥è¯†åº“æ•°æ®
window.viewIndexedDBKnowledge = async function() {
    try {
        const db = await window.contextVectorManager.openVectorDB('xiuxian_vector_db');
        const transaction = db.transaction(['staticKB'], 'readonly');
        const store = transaction.objectStore('staticKB');
        
        const request = store.get('main');
        const result = await new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        
        if (!result || !result.knowledge) {
            console.log('âŒ IndexedDBä¸­æ²¡æœ‰é™æ€çŸ¥è¯†åº“æ•°æ®');
            return;
        }
        
        const kb = result.knowledge;
        const denseCount = kb.filter(item => item.vector && Array.isArray(item.vector)).length;
        const sparseCount = kb.filter(item => item.vector && !Array.isArray(item.vector)).length;
        const lazyCount = kb.filter(item => !item.vector).length;
        
        console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘  ğŸ’¾ IndexedDBé™æ€çŸ¥è¯†åº“                         â•‘');
        console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
        console.log(`â•‘  æ€»æ¡æ•°ï¼š${kb.length}                              â•‘`);
        console.log(`â•‘  ç¨ å¯†å‘é‡ï¼š${denseCount}æ¡                           â•‘`);
        console.log(`â•‘  ç¨€ç–å‘é‡ï¼š${sparseCount}æ¡                           â•‘`);
        console.log(`â•‘  å»¶è¿Ÿç”Ÿæˆï¼š${lazyCount}æ¡                           â•‘`);
        console.log(`â•‘  ä¿å­˜æ—¶é—´ï¼š${new Date(result.timestamp).toLocaleString('zh-CN')} â•‘`);
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        return kb;
    } catch (error) {
        console.error('âŒ æŸ¥çœ‹IndexedDBå¤±è´¥:', error);
    }
};

// ğŸ†• å…¨å±€è¾…åŠ©å‡½æ•°ï¼šæ¸…ç†å‘é‡åº“ä¸­å·²åˆ é™¤å¯¹è¯çš„æ¡ç›®
window.cleanVectorLibrary = async function() {
    if (!window.contextVectorManager) {
        console.error('âŒ å‘é‡ç®¡ç†å™¨æœªåˆå§‹åŒ–');
        return;
    }
    
    if (!window.gameState || !window.gameState.conversationHistory) {
        console.error('âŒ æ¸¸æˆçŠ¶æ€æœªåˆå§‹åŒ–');
        return;
    }
    
    const vectorLibrary = window.contextVectorManager.conversationEmbeddings;
    const conversationHistory = window.gameState.conversationHistory;
    
    // è®¡ç®—å½“å‰å®é™…çš„æ€»è½®æ•°ï¼ˆæ¯è½® = ç”¨æˆ·æ¶ˆæ¯ + AIå›å¤ï¼‰
    const actualTurns = Math.floor(conversationHistory.length / 2);
    
    console.log(`[å‘é‡åº“æ¸…ç†] å½“å‰å¯¹è¯å†å²ï¼š${conversationHistory.length}æ¡æ¶ˆæ¯ï¼Œ${actualTurns}è½®å¯¹è¯`);
    console.log(`[å‘é‡åº“æ¸…ç†] å½“å‰å‘é‡åº“ï¼š${vectorLibrary.length}æ¡è®°å½•`);
    
    // æ‰¾å‡ºå‘é‡åº“ä¸­ä¸å­˜åœ¨çš„è½®æ¬¡
    const invalidEntries = [];
    vectorLibrary.forEach((entry, index) => {
        if (entry.turnIndex > actualTurns) {
            invalidEntries.push({ index, turnIndex: entry.turnIndex });
        }
    });
    
    if (invalidEntries.length === 0) {
        console.log('âœ… å‘é‡åº“æ•°æ®å®Œæ•´ï¼Œæ— éœ€æ¸…ç†');
        return;
    }
    
    console.log(`âš ï¸  å‘ç° ${invalidEntries.length} æ¡æ— æ•ˆè®°å½•ï¼š`);
    invalidEntries.forEach(entry => {
        console.log(`   - ç¬¬${entry.turnIndex}è½®ï¼ˆç´¢å¼•${entry.index}ï¼‰- å·²è¶…å‡ºå®é™…å¯¹è¯è½®æ•°`);
    });
    
    // ä»åå¾€å‰åˆ é™¤ï¼Œé¿å…ç´¢å¼•é”™ä¹±
    for (let i = invalidEntries.length - 1; i >= 0; i--) {
        vectorLibrary.splice(invalidEntries[i].index, 1);
    }
    
    console.log(`âœ… å·²æ¸…ç† ${invalidEntries.length} æ¡æ— æ•ˆè®°å½•`);
    console.log(`ğŸ“Š æ¸…ç†åå‘é‡åº“å¤§å°ï¼š${vectorLibrary.length}æ¡`);
    
    // ä¿å­˜åˆ°IndexedDB
    try {
        await window.contextVectorManager.saveToIndexedDB();
        console.log('ğŸ’¾ å·²ä¿å­˜åˆ°IndexedDB');
    } catch (error) {
        console.warn('âš ï¸  ä¿å­˜åˆ°IndexedDBå¤±è´¥:', error);
    }
};

console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
console.log('â•‘  ğŸ§¬ å‘é‡æ£€ç´¢ç³»ç»Ÿå·²åŠ è½½                          â•‘');
console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
console.log('â•‘  ğŸ“¦ å½“å‰é…ç½®ï¼š                                  â•‘');
console.log(`â•‘    - å‘é‡åŒ–æ–¹æ³•ï¼š${window.contextVectorManager.embeddingMethod.padEnd(20)}â•‘`);
console.log(`â•‘    - ä½¿ç”¨æœ¬åœ°æ¨¡å‹ï¼š${window.contextVectorManager.modelConfig.useLocalModel ? 'âœ… æ˜¯' : 'âŒ å¦'}                      â•‘`);
console.log(`â•‘    - é‡åŒ–æ¨¡å‹ï¼š${window.contextVectorManager.modelConfig.useQuantized ? 'âœ… å¯ç”¨ï¼ˆ13MBï¼‰' : 'âŒ ç¦ç”¨ï¼ˆ50MBï¼‰'}              â•‘`);
console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
console.log('â•‘  ğŸ’¡ å¿«é€Ÿå‘½ä»¤ï¼š                                  â•‘');
console.log('â•‘    showModelConfig()  - æŸ¥çœ‹è¯¦ç»†é…ç½®            â•‘');
console.log('â•‘    showKnowledgeBase()  - æŸ¥çœ‹é™æ€çŸ¥è¯†åº“       â•‘');
console.log('â•‘    testStaticKB("å…³é”®è¯")  - æµ‹è¯•çŸ¥è¯†åº“æ£€ç´¢    â•‘');
console.log('â•‘    viewIndexedDBKnowledge()  - æŸ¥çœ‹IndexedDB   â•‘');
console.log('â•‘    cleanVectorLibrary()  - æ¸…ç†å‘é‡åº“æ— æ•ˆè®°å½•  â•‘');
console.log('â•‘    useLocalModel(true)  - åˆ‡æ¢åˆ°æœ¬åœ°æ¨¡å‹       â•‘');
console.log('â•‘    useQuantizedModel(true)  - å¯ç”¨é‡åŒ–æ¨¡å‹     â•‘');
console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

